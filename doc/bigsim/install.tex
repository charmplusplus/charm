\section{BigSim Simulator Installation and Usage}
\label{install}

\subsection{Installing Charm++ and BigSim}

BigSim Simulator is distributed as a part of the Charm++ standard distribution.
One needs to download Charm++ and compile BigSim simulator.
One should begin with downloading Charm++ from the website:
http://charm.cs.uiuc.edu.

Please refer to ``Charm++ Installation and Usage Manual" and also the file
README in the source code for detailed instructions on how to compile Charm++.
In short, the ``build" script is the main tool for compiling \charmpp{}.  You
need to provide target and platform options: \begin{verbatim} ./build <target>
<platform> [options ...] [charmc-options ...] \end{verbatim}

For example, to compile on a Linux machine, type:
\begin{verbatim}
./build charm++ net-linux -O
\end{verbatim}

which builds essential \charmpp{} kernel using UDP sockets as 
communication method, 
alternatively, you can build Charm++ kernel on MPI using:
\begin{verbatim}
./build charm++ mpi-linux -O
\end{verbatim}

For other platforms, change net-linux to whatever platform you are compiling 
on. See the charm/README file for a complete list of supported platforms.

\subsubsection{Build Only the BigSim Emulator}

BigSim emulator is implemented on top of Converse in Charm++.
To compile BigSim emulator, one can compile emulator libraries
directly on top of normal Charm++ using ``bigsim'' as the compilation
target, like
\begin{verbatim}
./build bigsim net-linux -O
\end{verbatim}

With emulator libraries, one can write BigSim applications using its
low level emulator message passing API.

\subsubsection{Build Charm++ on BigSim Emulator}

In order to build Charm++ on top of BigSim Emulator (which itself is 
implemented on top of Converse), a special build option ``bigsim''
needs to be specified:
\begin{verbatim}
./build bigsim net-linux bigsim -O
\end{verbatim}

The first ``bigsim" is the compilation target that tells ``build" to
compile BigSim emulator libraries in addition to \charmpp{} kernel libraries;
The second ``bigsim" is a build option to platform ``net-linux", which tells
``build" to build the Charm++ on top of BigSim Emulator. 
To build AMPI on BigSim, use ``bgampi" as make target, which subsumes target
of ``bigsim":
\begin{verbatim}
./build bgampi net-linux bigsim -O
\end{verbatim}

For the above ``build" command, it creates a directory named 
``net-linux-bigsim" under charm, which contains all the header files and
libraries needed for compiling a user application.

\subsection{Compiling BigSim Applications}

\charmpp{} provides a compiler script {\tt charmc} to compile all programs.

There are three methods to write a BigSim application:

\subsubsection{Writing a BigSim application using low level machine API}
The low level machine API mimics the actual machine low level programming
API. It is defined in section~\ref{bgemulator}. Writing a program in the 
low level machine API, you just need to link \charmpp{}'s BigSim emulator
libraries, which provide the emulation of the machine API using Converse as
the communication layer.

In order to link against the BigSim library, specify 
\texttt{-language bigsim} as an argument to the {\tt charmc} linker, 
for example:
\begin{verbatim}
charmc -o hello hello.C -language bigsim
\end{verbatim}

Sample applications in low level machine API can be found under directory
charm/pgms/converse/bluegene.

\subsubsection{Writing a BigSim application in Charm++}

One can write a normal \charmpp{} application which can automatically 
run on the emulator after compilation. \charmpp{} implements
an object-based message-driven execution model. In \charmpp{} applications,
there are collections of C++ objects, which communicate by remotely invoking
methods on other objects by messages.

In order to compile a program written in \charmpp{} on Blue Gene simulator, 
specify \texttt{-language charm++} as an argument to the {\tt charmc} linker:
\begin{verbatim}
charmc -o hello hello.C -language charm++
\end{verbatim}
This will link both \charmpp{} runtime libraries and BigSim simulator 
libraries.

Sample applications in \charmpp{} can be found under directory
charm/pgms/charm++, specifically charm/pgms/charm++/littleMD.

\subsubsection{Writing a Blue Gene application in MPI}

One can also write a MPI application for Blue Gene Simulator.
The Adaptive MPI, or AMPI is implemented on top of Charm++ that supports
dynamic load balancing and multithreading for MPI applications. This is based
on the user-level migrating threads and load balancing capabilities provided
by the \charmpp{} framework. This allows legacy MPI programs to run 
on top of Blue Gene \charmpp{} and take advantage of the \charmpp{}'s
virtualization and adaptive load balancing capability.

Current AMPI implements most features in the MPI version 1.0, with a few
extensions for migrating threads and asynchronous reduction.

In order to compile an AMPI application on Blue Gene simulator, you need 
to link against the AMPI library as well as Blue Gene \charmpp{} runtime
libraries by specifying \texttt{-language ampi} as an argument to 
the {\tt charmc} linker:
\begin{verbatim}
charmc -o hello hello.C -language ampi
\end{verbatim}

Sample applications in AMPI can be found under directory
charm/pgms/charm++/ampi, specifically charm/pgms/charm++/Cjacobi3D.

\subsection{Run a BigSim Application}

To run a parallel Blue Gene application, \charmpp{} provides a utility program
called {\tt charmrun} to start the parallel program. 
For detailed description on how to run a \charmpp{} application, 
refer to the file charm/README in the source code distribution.

To run a Blue Gene application, you need to specify these parameters to 
{\tt charmrun} to define the simulated Blue Gene machine size:
\begin{enumerate}
\item {\tt +x, +y} and {\tt +z}:  define the size of the machine in three dimensions, these define the number of nodes along each dimension of the machine;
\item {\tt +wth} and {\tt +cth}:  For one node, these two parameters define the number of worker processors({\tt +wth}) and the number of communication processors({\tt +cth}).
\item {\tt +bgcorrect}: starts the simulation mode for performance prediction. Otherwise the program runs without doing parallel event simulation for performance prediction of the application.
\item {\tt +bgwalltime}: used only in simulation mode, when specified, use wallclock measurement of the time taken on the simulating machine to estimate the time it takes to run on the target machine.
\item {\tt +bgcounter}:  used only in simulation mode, when specified, use the performance counter to estimate the time on target machine. This is currently only supported when perfex is installed, like Origin2000.
\end{enumerate}

For example, to simulate a Blue Gene/L machine of size 64K in 40x40x40, with 
one worker processor and one I/O processor on each node, and use 100 
real processors to simulate:
\begin{verbatim}
./charmrun +p100 ./hello +x40 +y40 +z40 +cth1 +wth1
\end{verbatim}

To run an AMPI program, you may also want to specify the number of virtual 
processors to run the MPI by using {\tt +vp}, for example:
\begin{verbatim}
./charmrun +p100 ./hello +x40 +y40 +z40 +cth1 +wth1 +vp 128000
\end{verbatim}
starts the simulation of Blue Gene/L of size 40x40x40 with 2 processors 
in each node, running 128000 MPI threads (2 MPI threads on each Blue Gene node),
 using 100 real processors to simulate. In this case, {\tt MPI\_Comm\_size()}
returns 128000 for {\tt MPI\_COMM\_WORLD}. If you donot specify the {\tt +vp}
option, the number of virtual processors will be equal to the number of 
processors of the simulated machine, in this case 64000.


