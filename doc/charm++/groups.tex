\subsection{Group Objects}

\label{sec:group}

A \kw{group}\footnote{Originally called {\em Branch Office Chare} or 
{\em Branched Chare}} \index{group}is a collection of chares where 
there exists \index{chare}one chare (or {\sl branch}) on each
processor.   Each branch has its own data members.  Groups have
a definition syntax similar to normal chares,
and they have to inherit from the system defined class \kw{CBase}\_\uw{ClassName}.
\footnote{A deprecated older syntax allow them to inherit directly from the
system-defined class \kw{Group}}.

In the interface file, we declare

\begin{alltt}
 group GroupType \{
   // Interface specifications as for normal chares
 \};
\end{alltt}

In the \texttt{.h} file, we define \uw{GroupType} as follows:

\begin{alltt}
 class GroupType : public CBase\_GroupType \{
  // Data and member functions as in C++
  // Entry functions as for normal chares
 \};
\end{alltt}

A group is identified by a globally unique group identifier, whose type is
\kw{CkGroupID}. This identifier is common to all of the group's branches and
can be obtained from the variable \kw{thisgroup}, which is a public local
variable of the \kw{Group} superclass.  For groups, \kw{thishandle} is the
handle of the particular branch in which the function is executing: it is a
normal chare handle.

Groups can be used to implement data-parallel operations easily.  In addition
to sending messages to a particular branch of a group, one can broadcast
messages to all branches of a group.  There can be many instances corresponding
to a group type.  Each instance has a different group handle, and its own set
of branches.

\subsubsection{Group Creation}

Given a \texttt{.ci} file as follows:

\begin{alltt}
group G \{
  entry G(\uw{parameters1});
  entry void someEntry(\uw{parameters2});
\};
\end{alltt}

and the following \texttt{.h} file:

\begin{alltt}
class G : public CBase\_G \{
  public:
    G(\uw{parameters1});
    void someEntry(\uw{parameters2});
\};
\end{alltt}

we can create a \index{group}group in a manner similar to a regular
\index{chare}chare. 

\begin{alltt}
CProxy_G groupProxy = CProxy_G::ckNew(\uw{parameters1});
or
CkGroupID groupId = CProxy_G::ckNew(\uw{parameters1});
CProxy_G groupProxy(groupId);
\end{alltt}

It is possible to specify the dependence of group creations using
\uw{CkEntryOptions}, for example, creation of group B on each processor depends
on group A being created on that processor.

\begin{alltt}
// create group A
CkGroupID groupAId = CProxy_GroupA::ckNew(\uw{parameters1});

// create group B which depends on group A being created
CkEntryOptions opts;
opts.setGroupDepID(groupAId);
CkGroupID groupBId = CProxy_GroupB::ckNew(\uw{parameters2});
\end{alltt}

\subsubsection{Method Invocation on Groups}

Before sending a message to a \index{group}group via an entry
method, we need to get a proxy of that group.

A message may be sent to a particular \index{branch}branch of group using the
notation:

\begin{alltt}
 groupProxy[Processor].EntryMethod(\uw{parameters});
\end{alltt}

This sends the given parameters to the \index{branch}branch of
the group referred to by \uw{groupProxy} which is on processor number
\uw{Processor} at the entry method \uw{EntryMethod}, which must be a valid
entry method of that group type. This call is asynchronous and non-blocking; it
returns immediately after sending the message.

A message may be broadcast \index{broadcast} to all branches of a group
(i.e., to all processors) using the notation :

\begin{alltt}
 groupProxy.EntryMethod(\uw{parameters});
\end{alltt}

This sends the given parameters to all branches of the group at
the entry method \uw{EntryMethod}, which must be a valid entry method of that
group type. This call is asynchronous and non-blocking; it returns immediately
after sending the message.


Sequential objects, chares and other groups can gain access to the local
(i.e., on their processor) group object using:

\begin{alltt}
GroupType *g=groupProxy.ckLocalBranch();
\end{alltt}

This call returns a regular \CC\ pointer to the actual object (not a proxy)
referred to by the proxy \uw{groupProxy}.  Once a proxy to the
local branch of a group is obtained, that branch can be accessed as a regular
\CC\ object.  Its public methods can return values, and its public data is 
readily accessible.

Thus a dynamically created \index{chare}chare can call a public method of a
group without needing to know which processor it actually resides: the method
executes in the local \index{branch}branch of the group.

One very nice use of Groups is to reduce the number of messages sent between
processors by collecting the data from all the chares on a single processor
before sending that data to the mainchare.  To do this, create basic chares to
break up the work of a problem.  Also, create a group.  When a particular chare
finishes its work, it reports its findings to the local branch of the group.
When all the chares on one processor are complete, the local branch of the
group can then report to the main chare.  This reduces the number of messages
sent to main from the number of chares created to the number of processors. 







