/* All AMPI entry methods can be tagged 'expedited'
 * because AMPI does not use Charm++ message priorities. */
#define AMPI_USE_EXPEDITED_MSGS 1

#if AMPI_USE_EXPEDITED_MSGS
#define EXPEDITED               [expedited]
#define EXPEDITED_NOTRACE       [expedited,notrace]
#define EXPEDITED_NOKEEP        [expedited,nokeep]
#define EXPEDITED_REDN          [expedited,reductiontarget]
#define EXPEDITED_THREADED      [expedited,threaded]
#define EXPEDITED_THREADED_REDN [expedited,threaded,reductiontarget]
#define EXPEDITED_SYNC          [expedited,sync]
#define EXPEDITED_IGET          [expedited,iget]
#else
#define EXPEDITED               /*empty*/
#define EXPEDITED_NOTRACE       [notrace]
#define EXPEDITED_NOKEEP        [nokeep]
#define EXPEDITED_REDN          [reductiontarget]
#define EXPEDITED_THREADED      [threaded]
#define EXPEDITED_THREADED_REDN [threaded,reductiontarget]
#define EXPEDITED_IGET          [iget]
#define EXPEDITED_SYNC          [sync]
#endif

module ampi {
  message AmpiMsg {
    char data[];
  };

  initnode void ampiNodeInit(void);
  initproc void ampiProcInit(void);

  array[1D] ampiParent {
    entry EXPEDITED_NOTRACE ampiParent(int universeNo, CProxy_TCharm threads_);
    entry EXPEDITED void ResumeThread();
    entry EXPEDITED void Checkpoint(int len, char dname[len]);
    entry EXPEDITED void ExchangeProxy(CProxy_ampi);
  };

  array[1D] ampi {
    entry EXPEDITED ampi();
    entry EXPEDITED_NOTRACE ampi(CkArrayID parent_, ampiCommStruct s);
    entry EXPEDITED_REDN void allInitDone(void);
    entry EXPEDITED void setInitDoneFlag();
    entry EXPEDITED void unblock(void);
    entry EXPEDITED void ssend_ack(int);
    entry EXPEDITED void generic(AmpiMsg *);
    entry EXPEDITED_REDN void barrierResult(void);
    entry EXPEDITED_REDN void ibarrierResult(void);
    entry EXPEDITED_NOKEEP void rednResult(CkReductionMsg *msg);
    entry EXPEDITED_NOKEEP void irednResult(CkReductionMsg *msg);
    entry EXPEDITED_THREADED void splitPhase1(CkReductionMsg *msg);
    entry EXPEDITED_THREADED_REDN void commCreatePhase1(MPI_Comm nextGroupComm);
    entry EXPEDITED_THREADED_REDN void intercommCreatePhase1(MPI_Comm nextInterComm);
    entry EXPEDITED_THREADED_REDN void intercommMergePhase1(MPI_Comm nextIntraComm);

    entry EXPEDITED void setRemoteProxy(CProxy_ampi rproxy);
    entry EXPEDITED_SYNC void winRemotePut(int orgtotalsize, char orgaddr[orgtotalsize], int orgcnt,
                                           MPI_Datatype orgtype, MPI_Aint targdisp, int targcnt,
                                           MPI_Datatype targtype, int winIndex);
    entry EXPEDITED_SYNC AmpiMsg *winRemoteGet(int orgcnt, MPI_Datatype orgtype, MPI_Aint targdisp,
                                               int targcnt, MPI_Datatype targtype, int winIndex);
    entry EXPEDITED_SYNC void winRemoteAccumulate(int orgtotalsize, char orgaddr[orgtotalsize], int orgcnt,
                                                  MPI_Datatype orgtype, MPI_Aint targdisp, int targcnt,
                                                  MPI_Datatype targtype, MPI_Op op, int winIndex);
    entry EXPEDITED_SYNC AmpiMsg *winRemoteCompareAndSwap(int size, char sorgaddr[size],
                                                          char compaddr[size], MPI_Datatype type,
                                                          MPI_Aint targdisp, int winIndex);
    entry EXPEDITED_SYNC void winRemoteLock(int lock_type, int winIndex, int requestRank);
    entry EXPEDITED_SYNC void winRemoteUnlock(int winIndex, int requestRank);
    entry EXPEDITED_IGET AmpiMsg *winRemoteIget(MPI_Aint orgdisp, int orgcnt, MPI_Datatype orgtype,
                                                MPI_Aint targdisp, int targcnt, MPI_Datatype targtype,
                                                int winIndex);
    entry EXPEDITED_IGET AmpiMsg *Alltoall_RemoteIget(MPI_Aint disp, int cnt, MPI_Datatype type, int tag);
  };

  group [migratable] ampiWorlds {
    entry EXPEDITED ampiWorlds(ampiCommStruct nextWorld);
    entry EXPEDITED void add(ampiCommStruct nextWorld);
  };
};
