#!/bin/bash

is_restart=false
original_args=("$@")
pes_file="/dev/shm/numRestartProcs.txt"

# --- Pre-parse to find the nodelist for daemon startup ---
machinefile=""
for ((i=0; i<${#original_args[@]}; ++i)); do
    if [[ "${original_args[i]}" == "++nodelist" ]]; then
        machinefile="${original_args[i+1]}"
        break
    fi
done

num_nodes=0
if [[ -n "$machinefile" ]]; then
    if [[ ! -f "$machinefile" ]]; then
        echo "Charmrun> Error: nodelist file not found: $machinefile" >&2
        exit 1
    fi
    num_nodes=$(wc -l < "$machinefile")
else
    echo "Charmrun> Warning: ++nodelist not found. Assuming 1 node for HAPI daemon."
    num_nodes=1
fi

# --- Clean up and start the memory daemon in the background ---
# Read IP addresses and slots from nodelist file (format: ipaddress slots=X)
declare -A node_slots
node_ips=()
if [[ -n "$machinefile" ]]; then
    while IFS= read -r line; do
        # Extract IP address and slots count
        ip=$(echo "$line" | awk '{print $1}')
        slots=$(echo "$line" | grep -o 'slots=[0-9]*' | cut -d'=' -f2)
        if [[ -n "$ip" ]]; then
            node_ips+=("$ip")
            # Default to 1 slot if not specified
            node_slots["$ip"]=${slots:-1}
        fi
    done < "$machinefile"
else
    # Default to localhost if no nodelist
    node_ips=("localhost")
    node_slots["localhost"]=1
fi

# Clean up on all nodes via SSH (async)
cleanup_pids=()
for ip in "${node_ips[@]}"; do
    ssh "$ip" "rm -f /dev/shm/numRestartProcs.txt /tmp/server_fifo_* /tmp/client_fifo_* /tmp/daemon_ready_*; mkfifo -m 0666 /tmp/daemon_ready_0" &
    cleanup_pids+=($!)
done

# Wait for cleanup to complete on all nodes before starting daemons
for pid in "${cleanup_pids[@]}"; do
    wait "$pid"
done

# Start memory daemons on all nodes via SSH (async) - one daemon per slot
daemon_pids=()
for ip in "${node_ips[@]}"; do
    slots=${node_slots["$ip"]}
    echo "Starting $slots daemon(s) on node $ip"
    for ((slot=0; slot<slots; slot++)); do
        ssh "$ip" "cd $(pwd) && nohup ./hapi_memory_daemon $slot > /dev/null 2>&1 &" &
        daemon_pids+=($!)
    done
done

# Optional: Wait a brief moment for SSH connections to establish (non-blocking)
# sleep 1

# --- Main execution loop ---
while true; do
    # Reset and parse arguments for each run
    args=()
    pes_arg=""
    restart_arg=""

    temp_args=("${original_args[@]}")
    i=0
    while [ $i -lt ${#temp_args[@]} ]; do
        arg="${temp_args[$i]}"
        case "$arg" in
        +p|++p)
            i=$((i+1))
            pes_arg="$arg ${temp_args[$i]}"
            ;;
        +p[0-9]*)
            pes_arg="$arg"
            ;;
        ++p[0-9]*)
            pes_arg="$arg"
            ;;
        *)
            args+=("$arg")
            ;;
        esac
        i=$((i+1))
    done

    # Check the flag. If it's a restart, prepare the extra arguments.
    if [ "$is_restart" = true ]; then
        restart_arg="+restart /dev/shm"
        if [ -f "$pes_file" ]; then
            num_pes=$(cat "$pes_file")
            pes_arg="+p $num_pes"
        fi
    fi

    # Pass all script arguments to the executable
    "$(dirname "$0")/charmrun" $pes_arg "${args[@]}" $restart_arg

    EXIT_CODE=$?

    if [ "$EXIT_CODE" -eq 100 ]; then
        is_restart=true
        echo "Restart signal (code 100) received. Looping again."
        echo "----------------------------------------"
    else
        echo "Final exit signal (code $EXIT_CODE) received. Exiting loop."
        # Clean up the background daemon processes on all nodes
        for ip in "${node_ips[@]}"; do
            ssh "$ip" "pkill -f hapi_memory_daemon" &
        done
        # Also kill any remaining SSH connection PIDs
        for pid in "${daemon_pids[@]}"; do
            kill "$pid" 2>/dev/null
        done
        break
    fi
done

echo "Control loop finished."