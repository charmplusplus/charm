module DiffusionLB
{
  include "CentralLBMsg.h";
  extern module DistBaseLB;
  initnode void lbinit(void);

  group[migratable] DiffusionLB : DistBaseLB
  {
    entry void DiffusionLB(const CkLBOptions&);
    entry[reductiontarget] void statsAssembled();

    // DiffusionNeighbors
    entry[reductiontarget] void findNBors(int do_again);
    entry void startFirstRound();
    entry[reductiontarget] void findNBorsRound(int do_again);
    entry[expedited] void proposeNbor(int nborId);
    entry[expedited] void okayNbor(int agree, int nborId);

    entry void ReceiveFinalStats(
        std::vector<bool> isMigratable, std::vector<int> from_proc,
        std::vector<int> to_proc, int n_migrateobjs,
        std::vector<std::vector<LBRealType>> positions, std::vector<double> load);

    entry void ReceiveCentroid(int node, std::vector<LBRealType> centroid, int count);
    entry void ReceiveLoadInfo(int itr, double load, int node);
    entry void ReceiveStats(CkMarshalledCLBStatsMessage data);
    // entry void LoadTransfer(double load, int initPE, int objId);
    entry void LoadReceived(int objId, int fromPE);
    entry void AcrossNodeLB();

    entry void pseudolb_barrier(int allZero);

    entry[reductiontarget] void startStrategy();
    // entry [reductiontarget] void DoneNodeLB();
    // entry void MigratedHelper(LDObjHandle h, int waitBarrier);
    entry void ProcessMigrations();
    entry void next_phase(int val);
    entry void LoadMetaInfo(LDObjHandle h, double load);
    entry void MigrationDoneWrapper();  // Call when migration is complete
    entry void WithinNodeLB();

    entry void buildMSTinRounds(double best_weight, int best_parent, int best_to);
    entry void next_MSTphase(double newcost, int newparent, int newto);

    // entry void MigrationInfo(int to, int from);
    // entry void ResumeClients(CkReductionMsg * msg);
    // entry void ResumeClients(int balancing);

    entry void PseudoLoad(int itr, double load, int node);
    entry[reductiontarget] void pseudoDone(bool done);
    // entry void CallResumeClients();
    // entry void PrintDebugMessage(int len, double result[len]);

    entry void createCentroidList()
    {
      serial
      {
        nbors = new int[numNodes];
        allNodeCentroids.resize(numNodes);
        allNodeObjCount.resize(numNodes);
        allNodeDistances.resize(numNodes);

        int position_dim = 0;
        if (nodeStats->objData.size() > 0)
        {
          position_dim = nodeStats->objData[0].position.size();
        }

        // initialize centroid structures
        myCentroid.resize(position_dim, 0);
        for (int nbor = 0; nbor < numNodes; nbor++)
        {
          nbors[nbor] = nbor;
          allNodeCentroids[nbor].resize(position_dim, 0);
        }

        // compute my own centroid
        for (int objIdx = 0; objIdx < nodeStats->objData.size(); objIdx++)
        {
          LDObjData& objData = nodeStats->objData[objIdx];
          std::vector<LBRealType> position = nodeStats->objData[objIdx].position;

          for (int i = 0; i < position_dim; i++)
          {
            myCentroid[i] += objData.position[i];
          }
          // store centroid
        }

        for (int i = 0; i < position_dim; i++) myCentroid[i] /= nodeStats->objData.size();

        thisProxy.ReceiveCentroid(myNodeId, myCentroid, nodeStats->objData.size());
      }

      for (centReceiveNode = 0; centReceiveNode < numNodes; centReceiveNode++)
      {
        when ReceiveCentroid(int node, std::vector<LBRealType> centroid, int objCount)
            serial
        {
          position_dim = 3;
          // CkPrintf(
          //     "Node %d received centroid from %d with length %d, dest has size %d, "
          //     "mycentroid has size %d, allnode sitances has size %d\n",
          //     myNodeId, node, centroid.size(), allNodeCentroids[node].size(),
          //     myCentroid.size(), allNodeDistances.size());
          double dist = 0;
          for (int i = 0; i < position_dim; i++)
          {
            allNodeCentroids[node][i] = centroid[i];
          }

          for (int i = 0; i < position_dim; i++)
          {
            dist += (myCentroid[i] - centroid[i]) * (myCentroid[i] - centroid[i]);
          }
          dist = sqrt(dist);

          if (node != myNodeId)
          {
            allNodeDistances[node] = dist;
          }
          else
          {
            allNodeDistances[node] = 10000;
          }

          allNodeObjCount[node] = objCount;
        }
      }

      serial "Sorting nbors"
      {
        if (thisIndex == rank0PE)
        {
        pairedSort(nbors, allNodeDistances);
        buildMSTinRounds(best_weight, best_from, best_to);
        }
      }
    }

    entry void pseudolb_rounds()
    {
      serial
      {
        std::string neighborsStr;
        for (int i = 0; i < neighborCount; i++)
        {
          neighborsStr += std::to_string(sendToNeighbors[i]);
          if (i < neighborCount - 1)
          {
            neighborsStr += ", ";
          }
        }

        CkPrintf("Node %d has neighbors: %s\n", myNodeId, neighborsStr.c_str());

        loadNeighbors.clear();
        toSendLoad.clear();

        loadNeighbors.resize(neighborCount, 0);
        toSendLoad.resize(neighborCount, 0);
        toReceiveLoad.resize(neighborCount, 0);

        my_pseudo_load = my_load;
      }

      // TODO: Currently fixed iterations
      for (pseudo_itr = 0; pseudo_itr < ITERATIONS; pseudo_itr++)
      {
        // Send its load
        serial "Communicate load info"
        {
          for (int i = 0; i < neighborCount; i++)
          {
            thisProxy[sendToNeighbors[i] * nodeSize].ReceiveLoadInfo(
                pseudo_itr, my_pseudo_load, myNodeId);
          }
        }

        // Wait for all its neighbors load
        for (temp_itr = 0; temp_itr < sendToNeighbors.size(); temp_itr++)
        {
          when ReceiveLoadInfo[pseudo_itr](int itr, double load, int node) serial
          {
            int pos = findNborIdx(node);
            loadNeighbors[pos] = load;
          }
        }

        // Calculate average and do pseudo load balancing
        serial "Pseudo LB"
        {
          // avgLoadNeighbor = avgNborLoad();
          PseudoLoadBalancing();
        }

        for (temp_itr = 0; temp_itr < sendToNeighbors.size(); temp_itr++)
        {
          when PseudoLoad[pseudo_itr](int itr, double load, int node) serial
          {
            my_pseudo_load += load;
            int pos = findNborIdx(node);
            toSendLoad[pos] -= load;
          }
        }

        when pseudoDone(bool doneInPseudo) serial
        {
          if (doneInPseudo)
          {
            pseudo_itr = ITERATIONS;
          }
        }
      }

      // Calculate the aggregate load that has to be sent.
      serial "Aggregate load"
      {
        CkPrintf("PSEUDO: Node %d (load %f) with pseudo_load after LB %f\n", myNodeId,
                 my_load, my_pseudo_load);
        // for (int i = 0; i < neighborCount; i++)
        // {
        //   CkPrintf("PSEUDO: Node %d sending %f to %d\n", myNodeId, toSendLoad[i],
        //            sendToNeighbors[i]);
        // }
        loadReceivers = 0;
      }
    }
  };
};
