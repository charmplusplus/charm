module DiffusionLB
{
  include "CentralLBMsg.h";
  extern module DistBaseLB;
  initnode void lbinit(void);

  group[migratable] DiffusionLB : DistBaseLB
  {
    entry void DiffusionLB(const CkLBOptions&);
    entry[reductiontarget] void statsAssembled();

    // DiffusionNeighbors
    entry[reductiontarget] void findNBors(int do_again);
    entry void startFirstRound();
    entry[reductiontarget] void findNBorsRound(int do_again);
    entry[expedited] void proposeNbor(int nborId);
    entry[expedited] void okayNbor(int agree, int nborId);

    entry void ReceiveLoadInfo(int itr, double load, int node);
    entry void ReceiveStats(CkMarshalledCLBStatsMessage data);
    // entry void LoadTransfer(double load, int initPE, int objId);
    entry void LoadReceived(int objId, int fromPE);
    entry void AcrossNodeLB();
    entry[reductiontarget] void startStrategy();
    // entry [reductiontarget] void DoneNodeLB();
    // entry void MigratedHelper(LDObjHandle h, int waitBarrier);
    entry void ProcessMigrations();
    entry void next_phase(int val);
    entry void LoadMetaInfo(LDObjHandle h, double load);
    entry void MigrationDoneWrapper();  // Call when migration is complete
    entry void WithinNodeLB();

    entry void buildMSTinRounds(double best_weight, int best_parent, int best_to);
    entry void next_MSTphase(double newcost, int newparent, int newto);

    // entry void MigrationInfo(int to, int from);
    // entry void ResumeClients(CkReductionMsg * msg);
    // entry void ResumeClients(int balancing);

    entry void PseudoLoad(int itr, double load, int node);
    // entry void CallResumeClients();
    // entry void PrintDebugMessage(int len, double result[len]);

    entry void pseudolb_rounds()
    {
      serial
      {
        std::string neighborsStr;
        for (int i = 0; i < neighborCount; i++)
        {
          neighborsStr += std::to_string(sendToNeighbors[i]);
          if (i < neighborCount - 1)
          {
            neighborsStr += ", ";
          }
        }

        CkPrintf("Node %d has neighbors: %s\n", myNodeId, neighborsStr.c_str());

        loadNeighbors.resize(neighborCount, 0);
        toSendLoad.resize(neighborCount, 0);
        toReceiveLoad.resize(neighborCount, 0);

        my_pseudo_load = my_load;
      }
      // TODO: Currently fixed iterations
      for (pseudo_itr = 0; pseudo_itr < ITERATIONS; pseudo_itr++)
      {
        // Send its load
        serial "Communicate load info"
        {
          for (int i = 0; i < neighborCount; i++)
          {
            thisProxy[sendToNeighbors[i] * nodeSize].ReceiveLoadInfo(
                pseudo_itr, my_pseudo_load, myNodeId);
          }
        }

        // Wait for all its neighbors load
        for (temp_itr = 0; temp_itr < sendToNeighbors.size(); temp_itr++)
        {
          when ReceiveLoadInfo[pseudo_itr](int itr, double load, int node) serial
          {
            int pos = findNborIdx(node);
            loadNeighbors[pos] = load;
          }
        }

        // Calculate average and do pseudo load balancing
        serial "Pseudo LB"
        {
          avgLoadNeighbor = avgNborLoad();
          PseudoLoadBalancing();
        }

        for (temp_itr = 0; temp_itr < sendToNeighbors.size(); temp_itr++)
        {
          when PseudoLoad[pseudo_itr](int itr, double load, int node) serial
          {
            my_pseudo_load += load;
            int pos = findNborIdx(node);
            toReceiveLoad[pos] += load;
          }
        }
      }

      // Calculate the aggregate load that has to be sent.
      serial "Aggregate load"
      {
              for (int i = 0; i < neighborCount; i++) toSendLoad[i] -= toReceiveLoad[i];
        loadReceivers = 0;
      }
    }
  };
};
