
AC_INIT(./Makefile)

AC_CONFIG_HEADER(conv-autoconfig.h)

AC_CONFIG_COMMANDS([config-cleanup],
                   [sed -i -e 's:^#define\s\+PACKAGE://&:' conv-autoconfig.h])

#clean up conv-mach-opt.sh
sed -e '/Option added by configure/d' ../include/conv-mach-opt.sh  | sed -e '/^$/d' > conv-mach-opt.sh.clean
cp -f conv-mach-opt.sh.clean   ../include/conv-mach-opt.sh
rm -f conv-mach-opt.sh.clean

CHARMINC="."
CHARMBIN="../bin"
test -r ./conv-config.sh && . ./conv-config.sh

# Decimal representation of Charm++ release line and API revision
# Increment the last 2 digits when making an API change
# Increase the first three after branching for a release
VERSION=60800
echo $VERSION > ../include/VERSION
AC_DEFINE_UNQUOTED([CHARM_VERSION], $VERSION, [Charm++ Release/API version number])

charmout="charmconfig.out"
/bin/rm -rf $charmout
MAKEFILE_EXT=Make.extlib

Echo() {
	echo $* 
	echo $* >> $charmout
}

# add into conv-mach-opt.sh
# add_flag $1 $2
# $2 is description
add_flag() {
        key=`echo $1 | cut -d'=' -f1`
        last=`grep "$key=" ../include/conv-mach-opt.sh 2>/dev/null | tail -1 | sed -e 's/ *#.*$//'`
        skip=0
	if test -n "$last" -a  "$last" = "$1" 
	then
	  skip=1
        fi
	if test $skip = 0
        then
	  cat >> ../include/conv-mach-opt.sh << EOT

$1   # Option added by configure script's $2 section
EOT
	fi
}

# remove_flag $1
remove_flag() {
     sed -e '/^'"$1"'=/d' ../include/conv-mach-opt.sh > tmp.$$
     cp tmp.$$ ../include/conv-mach-opt.sh
     /bin/rm -f tmp.$$
}

# enable/disable error checking
AC_ARG_ENABLE([error-checking],
            [AS_HELP_STRING([--enable-error-checking],
              [enable error checking])], ,
            [enable_error_checking=yes])

if test "$enable_error_checking" = "no"
then
  Echo "Error checking is disabled" 
  AC_DEFINE_UNQUOTED(CMK_ERROR_CHECKING, 0, [disable error checking])
  add_flag 'OPTS_CC="$OPTS_CC -U_FORTIFY_SOURCE"' 'error checking'
  add_flag 'OPTS_CXX="$OPTS_CXX -U_FORTIFY_SOURCE"' 'error checking'
else
  Echo "Error checking is enabled" 
  AC_DEFINE_UNQUOTED(CMK_ERROR_CHECKING, 1, [enable error checking])
fi

# enable/disable AMPI error checking
AC_ARG_ENABLE([ampi-error-checking],
            [AS_HELP_STRING([--enable-ampi-error-checking],
              [enable AMPI error checking])], ,
            [enable_ampi_error_checking=yes])

if test "$enable_ampi_error_checking" = "no"
then
  Echo "AMPI error checking is disabled"
  AC_DEFINE_UNQUOTED(AMPI_ERROR_CHECKING, 0, [disable ampi error checking])
else
  Echo "AMPI error checking is enabled"
  AC_DEFINE_UNQUOTED(AMPI_ERROR_CHECKING, 1, [enable ampi error checking])
fi

# enable/disable statistics collection
AC_ARG_ENABLE([stats],
            [AS_HELP_STRING([--enable-stats],
              [enable statistics collection])], ,
            [enable_stats=yes])

if test "$enable_stats" = "no"
then
  Echo "Statistics collection is disabled" 
  AC_DEFINE_UNQUOTED(CMK_WITH_STATS, 0, [disable statistics collection])
else
  Echo "Statistics collection is enabled" 
  AC_DEFINE_UNQUOTED(CMK_WITH_STATS, 1, [enable statistics collection])
fi

# check enable/disable
AC_ARG_ENABLE([tracing],
            [AS_HELP_STRING([--enable-tracing],
              [enable tracing modules])], ,
            [enable_tracing=yes])

if test "$enable_tracing" = "no"
then
  Echo "Charm tracing is disabled"
  AC_DEFINE_UNQUOTED(CMK_TRACE_ENABLED, 0, [disable tracing])
  add_flag CMK_TRACE_ENABLED=0
else
  Echo "Charm tracing is enabled"
  AC_DEFINE_UNQUOTED(CMK_TRACE_ENABLED, 1, [enable tracing])
  add_flag CMK_TRACE_ENABLED=1
fi

AC_ARG_ENABLE([tracing-commthread],
            [AS_HELP_STRING([--enable-tracing-commthread],
              [enable tracing communication thread])], ,
            [enable_tracing_commthread=no])

if test "$enable_tracing_commthread" = "yes"
then
  Echo "Charm tracing communication thread is enabled"
  AC_DEFINE_UNQUOTED(CMK_SMP_TRACE_COMMTHREAD, 1, [enable tracing comm thread])
else
  Echo "Charm tracing communication thread is disabled"
  AC_DEFINE_UNQUOTED(CMK_SMP_TRACE_COMMTHREAD, 0, [disable tracing comm thread])
fi


AC_ARG_ENABLE([charmdebug],
            [AS_HELP_STRING([--enable-charmdebug],
              [enable charmDebug])], ,
            [enable_charmdebug=yes])

if test "$enable_charmdebug" = "no"
then
  Echo "CharmDebug is disabled" 
  AC_DEFINE_UNQUOTED(CMK_CHARMDEBUG, 0, [disable charmdebug])
  add_flag CMK_CHARMDEBUG=0
else
  Echo "CharmDebug is enabled" 
  AC_DEFINE_UNQUOTED(CMK_CHARMDEBUG, 1, [enable charmdebug])
  add_flag CMK_CHARMDEBUG=1
fi

AC_ARG_ENABLE([replay],
            [AS_HELP_STRING([--enable-replay],
              [enable record/replay])],
            [enable_replay=$enableval],
            [enable_replay=yes])

if test "$enable_replay" = "no"
then
  Echo "Charm record/replay is disabled"
  AC_DEFINE_UNQUOTED(CMK_REPLAYSYSTEM, 0, [disable replay])
else
  Echo "Charm record/replay is enabled"
fi

AC_ARG_ENABLE([ccs],
            [AS_HELP_STRING([--enable-ccs],
              [enable CCS])], ,
            [enable_ccs=yes])

if test "$enable_ccs" = "no"
then
  Echo "CCS is disabled" 
  AC_DEFINE_UNQUOTED(CMK_CCS_AVAILABLE, 0, [disable ccs])
else
  Echo "CCS is enabled" 
  AC_DEFINE_UNQUOTED(CMK_CCS_AVAILABLE, 1, [enable ccs])
fi

AC_ARG_ENABLE([controlpoint],
            [AS_HELP_STRING([--enable-controlpoint],
              [enable control point])],
            [enable_controlpoint=$enableval],
            [enable_controlpoint=yes])

if test "$enable_controlpoint" = "yes"
then
  Echo "Charm control point is enabled"
  AC_DEFINE_UNQUOTED(CMK_WITH_CONTROLPOINT, 1, [enable controlpoint])
else
  Echo "Charm control point is disabled"
  AC_DEFINE_UNQUOTED(CMK_WITH_CONTROLPOINT, 0, [disable controlpoint])
fi

AC_ARG_ENABLE([lbuserdata],
            [AS_HELP_STRING([--enable-lbuserdata],
              [enable LB user data])],
            [enable_lbuserdata=$enableval],
            [enable_lbuserdata=no])

if test "$enable_lbuserdata" = "yes"
then
  Echo "Charm LB user data is enabled"
  AC_DEFINE_UNQUOTED(CMK_LB_USER_DATA, 1, [enable lb user data])
else
  Echo "Charm LB user data  is disabled"
  AC_DEFINE_UNQUOTED(CMK_LB_USER_DATA, 0, [disable lb user data])
fi

AC_ARG_ENABLE([shrinkexpand],
            [AS_HELP_STRING([--enable-shrinkexpand],
              [enable malleable jobs / shrink expand])],
            [enable_shrinkexpand=$enableval],
            [enable_shrinkexpand=no])

if test "$enable_shrinkexpand" = "yes"
then
  if test "$enable_ccs" = "no"
  then
    Echo "CCS cannot be disabled when enabling shrink-expand"
    test_finish 1
  else
    Echo "Charm shrink expand is enabled - Controlpoint is disabled."
    AC_DEFINE_UNQUOTED(CMK_SHRINK_EXPAND, 1, [enable shrinkexpand])
    AC_DEFINE_UNQUOTED(CMK_WITH_CONTROLPOINT, 0, [disable controlpoint])
  fi
else
  Echo "Charm shrink expand is disabled"
  AC_DEFINE_UNQUOTED(CMK_SHRINK_EXPAND, 0, [disable shrinkexpand])
fi

AC_ARG_WITH([numa],
            [AS_HELP_STRING([--with-numa],
              [support memory affinity with NUMA])],
            [],
            [with_numa=no])

WITH_NUMA=no
if test "$with_numa" = "yes"
then
  Echo "Charm NUMA support is builtin"
  WITH_NUMA=yes
fi

AC_ARG_WITH([lbtime-type],
            [AS_HELP_STRING([--with-lbtime-type=type],
                            [load balancing timer type])],
            [], [with_lbtime_type=double])

if test "$with_lbtime_type" = "float" -o "$with_lbtime_type" = "double"
then
  Echo "Setting load balancing timer type as '$with_lbtime_type'"
  AC_DEFINE_UNQUOTED(CMK_LBTIME_TYPE, $with_lbtime_type, [Setting load balancing timer type])
else
  Echo "Invalid type specified for load balancing timer type"
  test_finish 1
fi

AC_ARG_WITH([qlogic],
            [AS_HELP_STRING([--with-qlogic],
              [QLogic based Infiniband])],[with_qlogic=yes],
            [with_qlogic=no])

if test "$with_qlogic" = "no"
then
  AC_DEFINE_UNQUOTED(QLOGIC, 0, [disable qlogic])
else
  Echo "QLogic based Infiniband"
  AC_DEFINE_UNQUOTED(QLOGIC, 1, [enable qlogic])
fi

#
AC_MSG_CHECKING(machine name)
version=`pwd | awk -F/ '{print $(NF-1)}'`
base_version=`cat .vdir`
AC_DEFINE_UNQUOTED(CMK_MACHINE_NAME, "$version",[machine name])
AC_MSG_RESULT($version)
AC_SUBST(base_version)

t="test.cpp"
tc="test.c"

# test result passed in $1
# If the test suceeded, print $3 and set "pass"/clear "fail"
# If the test failed, print $2 and clear "pass"/set "fail"
test_result() {
	if test $1 -eq 0
	then
                AC_MSG_RESULT("$3")
		pass="1"
		fail="0"
	else
                AC_MSG_RESULT("$4")
		pass="0"
		fail="1"
# For debugging the configure script, just "export autoconf_debug=1"
#  to get this verbose data on any failed tests:
		if test ! -z "$autoconf_debug"
		then
			echo "------- test script for $2 failed:"
			cat out
			echo "------- the test program was:"
			cat $t
			echo "-------"
		fi
	fi
}

# Test: tries to compile C file $t (described by $1).
#  If successful, prints $2 and sets $pass/clears $fail
#  If failure, prints $3 and sets $pass/clears $fail
#  additional arguments to c++ compiler are passed as $4
test_cc() {
        AC_MSG_CHECKING("$1")
	echo "### $1" >> $charmout
	cat $tc >> $charmout
	echo $CMK_CC -I../include -I. $CMK_LIBDIR $CMK_INCDIR $CMK_SYSINC $OPTS_CC $OPTS_LD -c $tc -o test.o $4 >> $charmout
	$CMK_CC -I../include -I. $CMK_LIBDIR $CMK_INCDIR $CMK_SYSINC $OPTS_CC $OPTS_LD -c $tc -o test.o $4 > out 2>&1
	test_result $? "$1" "$2" "$3"
 	strictpass=$pass
	strictfail=$fail
        if test $pass -eq 1
	then 
 	  if cat out | grep -i "warn" > /dev/null 2>&1
	  then 
	    strictpass="0" && strictfail="1"
          fi
        fi
	cat out >> $charmout
	/bin/rm -f out
}

# Test: tries to compile C++ file $t (described by $1).
#  If successful, prints $2 and sets $pass/clears $fail
#  If failure, prints $3 and sets $pass/clears $fail
#  additional arguments to c++ compiler are passed as $4
test_cxx() {
        AC_MSG_CHECKING("$1")
	echo "### $1" >> $charmout
	cat $t >> $charmout
	echo $CMK_CXX -I../include -I. $CMK_LIBDIR $CMK_INCDIR $CMK_SYSINC $OPTS_CXX $OPTS_LD -c $t -o test.o $4 >> $charmout
	$CMK_CXX -I../include -I. $CMK_LIBDIR $CMK_INCDIR $CMK_SYSINC $OPTS_CXX $OPTS_LD -c $t -o test.o $4 > out 2>&1
	test_result $? "$1" "$2" "$3"
 	strictpass=$pass
	strictfail=$fail
        if test $pass -eq 1
	then 
 	  if cat out | grep -i "warn" > /dev/null 2>&1
	  then 
	    strictpass="0" && strictfail="1"
          fi
        fi
	cat out >> $charmout
	/bin/rm -f out
}

# Testlink: tries to compile and link a C++ file $t (described by $1).
#  If successful, prints $2 and sets $pass/clears $fail
#  If failure, prints $3 and sets $pass/clears $fail
#  additional arguments to c++ compiler are passed as $4
test_link() {
        AC_MSG_CHECKING("$1")
	echo "### $1" >> $charmout
	cat $t >> $charmout
	echo $CMK_CXX -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CXX -c $t -o test.o $4 >> $charmout
	$CMK_CXX -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CXX -c $t -o test.o $4 > out 2>&1
        if test $? -ne 0
        then
          test_result 1 "$1" "$2" "$3"
        else
          echo $CMK_LDXX -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $4 >> $charmout
          $CMK_LDXX -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $4 >> out 2>&1
          ret=$?
	  test ! -x testlink && ret=1
          test_result $ret "$1" "$2" "$3"
        fi
 	strictpass=$pass
	strictfail=$fail
        if test $pass -eq 1
	then 
 	  if cat out | grep -i "warn" > /dev/null 2>&1
	  then 
	    strictpass="0" && strictfail="1"
          fi
        fi
	cat out >> $charmout
	/bin/rm -f out
}

# Testlinkc: tries to compile and link a C file $t (described by $1).
#  If successful, prints $2 and sets $pass/clears $fail
#  If failure, prints $3 and sets $pass/clears $fail
#  additional arguments to c++ compiler are passed as $4
test_linkc() {
        AC_MSG_CHECKING("$1")
	echo "### $1" >> $charmout
	cat $tc >> $charmout
	echo $CMK_CC -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CC -c $tc -o test.o $4 >> $charmout
	$CMK_CC -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CC -c $tc -o test.o $4 > out 2>&1
        if test $? -ne 0
        then
          test_result 1 "$1" "$2" "$3"
        else
          echo $CMK_LD -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $4 >> $charmout
          $CMK_LD -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $4 >> out 2>&1
          test_result $? "$1" "$2" "$3"
        fi
 	strictpass=$pass
	strictfail=$fail
        if test $pass -eq 1
	then 
 	  if cat out | grep -i "warn" > /dev/null 2>&1
	  then 
	    strictpass="0" && strictfail="1"
          fi
        fi
	cat out >> $charmout
	/bin/rm -f out
}

# test_linkso $1 $2 $3 $4, where
# $1: debug msg
# $2: yes msg
# $3: no msg
# $4: extra link option
test_linkso() {
        AC_MSG_CHECKING("$1")
	echo $1 >> $charmout
	cat $t >> $charmout
	echo $CMK_CXX -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CXX $CMK_PIC -c $t -o test.o $4 >> $charmout
	$CMK_CXX -I../include -I. $CMK_INCDIR $CMK_SYSINC $OPTS_CXX -c $CMK_PIC $t -o test.o $4 > out 2>&1
        if test $? = 1
        then
          test_result 1 "$1" "$2" "$3"
        else
	  echo $CMK_LD -I../include -I. $CMK_LIBDIR $OPTS_LD $CMK_LD_SHARED $CMK_SYSLIBS test.o -o testlink.$CMK_SHARED_SUF $4 >> $charmout
	  $CMK_LD -I../include -I. $CMK_LIBDIR $OPTS_LD $CMK_LD_SHARED $CMK_SYSLIBS test.o -o testlink.$CMK_SHARED_SUF $4 > out 2>&1
	  test_result $? "$1" "$2" "$3"
	fi
	cat out >> $charmout
	/bin/rm -f out testlink.$CMK_SHARED_SUF
}

test_finish() {
	rm -f $t $tc testlink test.o	> /dev/null 2>&1
	/bin/rm -f out
	test $1 -eq 1 && echo "*** Please find detailed output in charmconfig.out ***"
	exit $1
}

# detect certain architectures
if cat /proc/cpuinfo 2>/dev/null | grep 'POWER7'  > /dev/null
then
  AC_DEFINE_UNQUOTED(CMK_POWER7, 1, [whether is power7])
fi

# detect OS
OSNAME=`uname -s`
if test $OSNAME = "Linux"
then
  AC_DEFINE_UNQUOTED(CMK_OS_IS_LINUX, 1, [OS is Linux])
else
  AC_DEFINE_UNQUOTED(CMK_OS_IS_LINUX, 0, [OS is Linux])
fi

# test cp -p
AC_MSG_CHECKING("cp command as")
CP="cp -p"
touch test_file
if ! $CP test_file test_file.cp 2>err
then
  CP="cp"
fi
rm -f test_file test_file.cp
AC_MSG_RESULT($CP)
add_flag CP=\""$CP"\" "cp command"
 

cat > $t <<EOT
#include <stdio.h>
void foo(void) {
	printf("Hello, world!\n");
}
EOT

if test "$CMK_BUILD_CRAY" = "1"
then
#echo "Test for known incompatible compiler versions"

 if test "$CRAY_CC_VERSION" = "8.1.4"
 then
	echo "CCE 8.1.4 produces incorrect Charm++ code"
	echo "Please use a newer version of the CCE compiler"
	echo "e.g. module load cce/8.1.7"
	test_finish 1
 fi
fi

#echo "set C++ compiler as: $CMK_CXX $OPTS_CXX $OPTS"
AC_MSG_CHECKING("C++ compiler as")
AC_MSG_RESULT("$CMK_CXX $OPTS_CXX")
test_cxx "whether C++ compiler works" "ok" "no" ""
if test $fail -eq 1
then
	echo "Cannot compile C++ programs with $CMK_CXX"
	echo " (check your charm++ version)"
	test_finish 1
fi

cat > $t <<EOT
#include <stdio.h>
int main() {
	printf("Hello, world!\n");
	return 0;
}
EOT
#echo "set C++ linker as: $CMK_LDXX $OPTS_LDXX"
AC_MSG_CHECKING("C++ linker as")
AC_MSG_RESULT("$CMK_LDXX $OPTS_LDXX")
test_link "whether linker works" "ok" "no" ""
if test $fail -eq 1
then
	echo "Cannot link C++ programs with $CMK_LDXX"
	echo " (check your charm++ version)"
	test_finish 1
fi

AC_MSG_CHECKING("Native C++ compiler as")
AC_MSG_RESULT("$CMK_NATIVE_CXX")
AC_MSG_CHECKING("Sequential C++ compiler as")
AC_MSG_RESULT("$CMK_SEQ_CXX")

if test "$base_version" = "net-linux" 
then
  test_link "whether linker accept --allow-multiple-definition" "ok" "no" "-Wl,--allow-multiple-definition"
  if test $pass -eq 1
  then
        remove_flag CMK_LDXX
	add_flag CMK_LDXX='"$CMK_LDXX -Wl,--allow-multiple-definition"' "net-linux linker"
  fi
fi

if echo "$CMK_CC" | grep -E "gcc|clang|icc" > /dev/null 2> /dev/null
then
  test_link "whether compiler accept -fno-stack-protector" "ok" "no" "-fno-stack-protector"
  if test $strictpass -eq 1
  then
	add_flag OPTS_CC='"$OPTS_CC -fno-stack-protector"' "stack-protection disabling"
	add_flag OPTS_CXX='"$OPTS_CXX -fno-stack-protector"' "stack-protection disabling"
  fi
fi

#### check if C++ compiler will accept C++11 features without warning ####
# C++11 features in use:
# early variadic templates
# R-value and move semantics
# auto
cat > $t <<EOT
class CkMigrateMessage;

struct base {
  base(void) { }
  base(CkMigrateMessage *) { }
};

template <class Parent>
struct CBaseT1 : Parent {

  CBaseT1(void) :Parent()  { }
  CBaseT1(CkMigrateMessage *m) :Parent(m) { }
  CBaseT1(CBaseT1&& rhs) :Parent() { }

  template <typename... Args>
    CBaseT1(Args... args) : Parent(args...) { }
};

template struct CBaseT1<base>;
EOT
got_cpp11=""
test_cxx "whether C++ compiler supports C++11 without flags" "yes" "no" ""
if test $strictpass -eq 1
then
  got_cpp11="true"
else
# Flags for g++/clang++/icc(icpc), xlC++, pgCC, and CrayCC respectively
for i in "-std=c++0x" "-qlanglvl=extended0x" "--c++11" "-h std=c++11"; do
    test_cxx "whether C++ compiler supports C++11 with '$i'" "yes" "no" "$i"
    if test $strictpass -eq 1
    then
      add_flag "$(echo OPTS_CXX=\"\$OPTS_CXX $i\")" "Enable C++11 support"
      OPTS_CXX="$OPTS_CXX $i"
      got_cpp11="true"
      break
    fi
done
fi

if test -z $got_cpp11
then
  echo "Charm++ requires some C++11 support, but doesn't know the flag to enable it"
  test_finish 1
fi

# Figure out if the user has asked to enable the latest language standards
USER_ASKED_FOR_NEW_STD=`echo "$BUILDOPTS" | grep "-use-new-std" | wc -l`

# If the user has asked for the newer standards, check if the compilers know about them
if test $USER_ASKED_FOR_NEW_STD -ge 1
then

#### check if c compiler supports c11 compilation flags ####
cat > $tc <<EOT
#include <stdio.h>

int foo()
{
  return 0;
}
EOT
test_cc "whether c compiler knows of the c11 standard" "ok" "no" "$CMK_ENABLE_C11"
AC_DEFINE_UNQUOTED(CMK_COMPILER_KNOWS_C11, $pass, [whether c compiler knows of the c11 standard] )
if test $pass -eq 1
then
        # Record results for charmc's future use
        add_flag 'CMK_COMPILER_KNOWS_C11="1"' "c11"
        # For the rest of configure, append this to compilation flags
        OPTS_CC="$CMK_ENABLE_C11 $OPTS_CC"
fi

#### check if C++ compiler supports cpp11 compilation flags ####
cat > $t <<EOT
#include <iostream>

int foo()
{
  return 0;
}
EOT
test_cxx "whether c++ compiler knows of the cpp11 standard" "ok" "no" "$CMK_ENABLE_CPP11"
AC_DEFINE_UNQUOTED(CMK_COMPILER_KNOWS_CPP11, $pass, [whether c++ compiler knows of the cpp11 standard] )
if test $pass -eq 1
then
        # Record results for charmc's future use
        add_flag 'CMK_COMPILER_KNOWS_CPP11="1"' "cpp11"
        # For the rest of configure, append this to compilation flags
        OPTS_CXX="$CMK_ENABLE_CPP11 $OPTS_CXX"
fi

fi # endif USER_ASKED_FOR_NEW_STD


# Perform the tests

AC_ARG_WITH([refnum-type],
            [AS_HELP_STRING([--with-refnum-type=type],
                            [size of the envelope refnum field])],
            [], [with_refnum_type=no])

if test "$with_refnum_type" = "no" -o "$with_refnum_type" = "short"
then
  Echo "Setting charm++ envelope refnum field to unsigned short"
  AC_DEFINE_UNQUOTED(CMK_REFNUM_TYPE, unsigned short, [envelope refnum field set to UShort])
elif test "$with_refnum_type" = "int"
then
  Echo "Setting charm++ envelope refnum field to unsigned int"
  AC_DEFINE_UNQUOTED(CMK_REFNUM_TYPE, unsigned int, [envelope refnum field set to UInt])
else
  Echo "Invalid size specified for refnum field"
  test_finish 1
fi


AC_ARG_WITH([prio-type],
            [AS_HELP_STRING([--with-prio-type=type],
                            [size of expected message priorities])],
            [], [with_prio_type=bitvec])

if test "$with_prio_type" = "char" -o "$with_prio_type" = "short" -o "$with_prio_type" = "int" -o "$with_prio_type" = "long" -o "$with_prio_type" = "float" -o "$with_prio_type" = "double"
then
  Echo "Configuring support for message priorities of sizeof type $with_prio_type"
  AC_DEFINE_UNQUOTED(CMK_USE_STL_MSGQ, 1, [whether charm scheduler should use an STL-based msg q])
  AC_DEFINE_UNQUOTED(CMK_MSG_PRIO_TYPE, $with_prio_type, [expected message priorities are sizeof $with_prio_type])
elif test "$with_prio_type" = "bitvec"
then
  Echo "Configuring support for message priorities of arbitrary size (bitvectors)"
  AC_DEFINE_UNQUOTED(CMK_USE_STL_MSGQ, 0, [whether charm scheduler should use an STL-based msg q])
  AC_DEFINE_UNQUOTED(CMK_MSG_PRIO_TYPE, $with_prio_type, [expected message priorities are arbitrarily sized])
else
  Echo "Invalid size ($with_prio_type) specified for message priorities. Can only accept char, short, int, long, float, double and bitvec"
  test_finish 1
fi

# enable/disable randomized scheduler queue
AC_ARG_ENABLE([randomized-msgq],
            [AS_HELP_STRING([--enable-randomized-msgq],
              [enable a randomized msg queue (for debugging etc)])], ,
            [enable_randomized_msgq=no])

if test "$enable_randomized_msgq" = "yes" -a "$with_prio_type" != "bitvec"
then
  Echo "The charm message queue will be randomized (and will not respect priorities)"
  AC_DEFINE_UNQUOTED(CMK_RANDOMIZED_MSGQ, 1, [enable the randomized msgq in the scheduler])
else
  AC_DEFINE_UNQUOTED(CMK_RANDOMIZED_MSGQ, 0, [disable the randomized msgq in the scheduler])
  if test "$enable_randomized_msgq" = "yes"
  then
    Echo 'A randomized message queue is only available when --with-prio-type != bitvec.'
    Echo "Specify prio-type to be a data type long enough to hold the message priorities in your application"
    Echo "for example: --with-prio-type=int (or short / long etc)."
    test_finish 1
  fi
fi

#### Check if compiler if 64 bit ####
cat > $t <<EOT
#include <stdio.h>

int foo()
{
int x[[(int)(sizeof(void *) - 7)]]={0};
return x[[0]];
}
EOT
test_cxx "whether compiler generates code for 64-bit" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_SIZET_64BIT, $strictpass, [whether size_t 64bit])
in64bit=$strictpass


### Check if compiler supports std::alignment_of<> ###
cat > $t <<EOT
#include <type_traits>

int foo()
{
  return std::alignment_of<int>::value;
}
EOT
test_cxx "whether compiler supports std::alignment_of" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_ALIGNMENT_OF, $strictpass, [whether compiler supports std::alignment_of])


#### test if has values.h ####
cat > $t <<EOT
#include <values.h>
int main() { 
  double d = MAXDOUBLE;
  return 0;
}
EOT
test_cxx "whether has values.h " "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_VALUES_H, $pass, [whether has values.h])

#### test if has stdint.h ####
cat > $t <<EOT
#include <stdint.h>
int main() { 
  return 0;
}
EOT
test_cxx "whether has stdint.h " "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_STDINT_H, $pass, [whether has stdint.h])

#### test if has malloc.h ####
cat > $t <<EOT
#include <malloc.h>
int main() { 
  return 0;
}
EOT
test_cxx "whether has malloc.h " "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_MALLOC_H, $pass, [whether has malloc.h])

#### test if has alloca.h ####
cat > $t <<EOT
#include <alloca.h>
int main() {
  double *s=(double *)alloca(sizeof(double));
  *s=1.0;
  return 0;
}
EOT
test_cxx "whether has alloca.h " "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_ALLOCA_H, $pass, [whether has alloca.h])

#### test if has regex.h ####
cat > $t <<EOT
#include <regex.h>
int main() {
  regex_t re;
  regcomp(&re, ".*MOD.*", REG_EXTENDED|REG_NOSUB);
  return 0;
}
EOT
test_cxx "whether has regex.h " "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_REGEX_H, $pass, [whether has regex.h])

#### Check long long ####
cat > $t <<EOT
#include <stdlib.h>
long long foo(void) { return 17; }
EOT
test_cxx "whether long long works" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_LONG_LONG_DEFINED, $pass, [whether long long works])

#### Check __int64 ####
cat > $t <<EOT
#include <stdlib.h>
__int64 foo(void) { return 17; }
EOT
test_cxx "whether __int64 works" "yes" "no" ""
AC_DEFINE_UNQUOTED([CMK___int64_DEFINED], $pass, [whether __int64 works])

#### Check __int128 ####
cat > $t <<EOT
#include <stdlib.h>
int foo(void) {
  __int128   a;
  int x[[(int)(sizeof(__int128) - 15)]]={0};
  return x[[0]];
}
EOT
test_cxx "whether __int128 (128-bit integer) works" "yes" "no" ""
AC_DEFINE_UNQUOTED([CMK___int128_DEFINED], $pass, [whether __int128 works])
if test $pass -eq 1
then
  add_flag CMK_HAS_INT16=1
fi

#### Check __int128_t ####
cat > $t <<EOT
#include <stdlib.h>
int foo(void) {
  __int128_t   a;
  __uint128_t   b;
  a = a + a;
  int x[[(int)(sizeof(__int128_t) - 15)]]={0};
  return x[[0]];
}
EOT
test_cxx "whether __int128_t (128-bit integer) works" "yes" "no" ""
AC_DEFINE_UNQUOTED([CMK___int128_t_DEFINED], $pass, [whether __int128_t works])
if test $pass -eq 1
then
  add_flag CMK_HAS_INT16=1
fi

#### Check long double ####
cat > $t <<EOT
#include <stdlib.h>
long double foo(void) { return 17.0; }
EOT
test_cxx "whether long double works" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_LONG_DOUBLE_DEFINED, $strictpass, [whether long double works])

#### Check ucontext and FPU pointer ####
cat > $t <<EOT
#include <ucontext.h>
struct _libc_fpstate   fpstate;
fpregset_t *fp;
EOT
test_cxx "whether ucontext has FPU pointer" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_CONTEXT_FPU_POINTER, $pass, [whether ucontext has pointer])

if test $pass -eq 1
then
cat > $t <<EOT
#include <ucontext.h>

int main()
{
  ucontext_t context;
  context.uc_mcontext.uc_regs = 0;
}
EOT
test_cxx "whether ucontext uses uc_regs" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_CONTEXT_FPU_POINTER_UCREGS, $pass, [whether ucontext uses uc_regs union])
fi

cat > $t <<EOT
#include <ucontext.h>
vrregset_t *v_regs;
ucontext_t  uc;

void foo()
{
  vrregset_t *ptr = uc.uc_mcontext.v_regs;
}
EOT
test_cxx "whether ucontext has pointer (v_regs) of vector type" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_CONTEXT_V_REGS, $pass, [whether ucontext has pointer (v_regs) of vector type])

#### Check ucontext and FPU pointer ####
cat > $t <<EOT
#include <infiniband/verbs.h>
void test()
{
    struct ibv_context    *context;
    int ibPort;
    struct ibv_port_attr attr;
    if (ibv_query_port(context, ibPort, &attr) != 0) return;
    if (attr.link_layer == IBV_LINK_LAYER_INFINIBAND)  return;
}
EOT
test_cxx "whether ibverbs ibv_port_attr has link_layer field" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_IBV_PORT_ATTR_HAS_LINK_LAYER, $pass, [whether ibv_port_attr has link_layer field])


###################### C++ Compiler Features #####################

#### check C inline ####
cat > $tc <<EOT
inline static int foo()
{
  return 1;
}
EOT
test_cc "whether inline works in C" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_C_INLINE, $strictpass, [whether C inline works in C])

#### check if signed char is same as char ####
cat > $t <<EOT
#include <stdlib.h>
class er {
 protected:
   void operator()(char &v,const char *desc=NULL) {};
   void operator()(signed char &v,const char *desc=NULL) {};
};
EOT
test_cxx "whether C++ signed char and char differ" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_SIGNEDCHAR_DIFF_CHAR, $pass, [whether C++ signed char and char differ])

### check if varsize array on stack ####
cat > $t <<EOT
#include <stdio.h>
void foo()
{
  int size=10;
  char arr[size];
}

EOT
test_cxx "whether C++ allows declaration of varsize array" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_DECLARE_VARSIZE_ARRAY, $pass, [whether C++ allows declaration of variable sized array])

#### check if typeinfo exists and works #####
cat > $t <<EOT
#include <typeinfo>
const char *foo(void) {
	int x;
	return typeid(x).name();
}
EOT
test_cxx "whether typeinfo/typeid works" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_TYPEINFO, $pass, [whether typeinfo/typeid works])

#### check if iterator_traits is defined #####
cat > $t <<EOT
#include <iterator>

template <typename T> // T models Input Iterator
typename std::iterator_traits<T>::value_type accumulate(T first, T last)
{
      typename std::iterator_traits<T>::value_type result = 0;
      while(first != last)
            result += *first++;
      return result;
}
EOT
test_cxx "whether std::iterator_traits is defined" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_ITERATOR_TRAITS, $pass, [whether iterator_traits works])

#### check if std::distance is defined #####
cat > $t <<EOT
#include <vector>
#include <iterator>

int foo()
{
  std::vector<int> tree;
  return std::distance(tree.begin(), tree.end());
}
EOT
test_cxx "whether std::distance is defined" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_STD_DISTANCE, $pass, [whether std::distance works])

#### check if std::inserter is defined #####
cat > $t <<EOT
#include <list>
#include <iterator>

void foo()
{
  using namespace std;
  list<int> L;
  inserter ( L, L.end ( ) ) = 500;
}
EOT
test_cxx "whether std::inserter is defined" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_STD_INSERTER, $pass, [whether std::inserter works])


####### Check support for features added by the new C11 and CPP11 standards ########

#### check if std::unordered_map is defined #####
cat > $t <<EOT
#include <unordered_map>

int foo()
{
  std::unordered_map<int,int> myhashtbl;
  myhashtbl[[0]] = 42;
  myhashtbl[[1234]] = 0;
  return myhashtbl[[1234]];
}
EOT
test_cxx "whether std::unordered_map is defined" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_STD_UNORDERED_MAP, $pass, [whether std::unordered_map works])


#### check if anon structs are permitted #####
cat > $t <<EOT
#include <iostream>
using std::cout;

struct idx
{
    const static int dims = 3;
    union
    {
        int data[[dims]];
        struct { int x, y, z; };
    };

    idx(const int i=0, const int j=0, const int k=0): x(i), y(j), z(k) {}
};

int main()
{
    cout<<"Hello World!\n";
    idx myidx(1, 2, 3);
    cout<< "idx = ("
        << myidx.data[[0]] << ","
        << myidx.data[[1]] << ","
        << myidx.z << ")\n";
    return (myidx.data[[0]] == 1 && myidx.y == 2 && myidx.data[[2]] == 3);
}
EOT
test_cxx "whether anon structs are permitted" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_ANON_STRUCTS, $pass, [whether anon structs are permitted])


#### test if we can have multiple delete like this ####
cat > $t <<EOT
class foo {
public:
  void operator delete(void*p){};
  void operator delete(void*p,int*){};
};
EOT
test_cxx "whether operator delete can be overloaded in same class" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_MULTIPLE_DELETE, $strictpass, [whether operator delete can be overloaded in same class])

#### test if offsetof exists ####
cat > $t <<EOT
#include <stddef.h>

struct FooType {
        int f1;
        int f2;
        double f3;
};

void foo()
{
  int off = offsetof(FooType, f2);
}
EOT
test_cxx "whether offsetof is defined" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_OFFSETOF, $pass, [whether offsetof exists])

#### test if we can use gcc x86 assembly like this ####
cat > $t <<EOT
double foo(void)
{
  unsigned long long int v=0;
  int *lo=0+(int *)&v;
  int *hi=1+(int *)&v;
  __asm__ __volatile__(
      "rdtsc; movl %%edx,%0; movl %%eax,%1"
      : /* output  */ "=m" (*hi), "=m" (*lo)
      : /* input */
      : /* trashes */ "%edx", "%eax"
  );
  return v;
}
EOT
test_cxx "whether GCC x86 assembly works" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_GCC_X86_ASM, $strictpass, [Allows gcc x86 assembly.])

#### test if we can use gcc x86 assembly like this ####
if test $strictpass = 1
then
cat > $t <<EOT
int foo(void)
{
  int x;
  asm("lock incl %0" :: "m" (x));
  asm("lock decl %0" :: "m" (x));
  return x;
}
EOT
test_cxx "whether GCC x86 assembly for atomic increment works" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_GCC_X86_ASM_ATOMICINCREMENT, $strictpass, [Allows gcc x86 assembly for atomic increment.])
fi

#### test if we can use gcc IA64 assembly like this ####
cat > $t <<EOT
double foo(void)
{
        unsigned long long int x;
	__asm__ __volatile__("mov %0=ar.itc" : "=r"(x) :: "memory");
        return x;
}
EOT
test_cxx "whether GCC IA64 assembly works" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_GCC_IA64_ASM, $strictpass, [Allows gcc IA64 assembly.])


#### test if we can use asm eieio assembly like this ####
cat > $t <<EOT
double foo(void)
{
        unsigned long long int x;
	asm volatile("eieio" ::: "memory");
        return x;
}
EOT
test_cxx "whether asm eieio assembly works" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_PPC_ASM, $strictpass, [Allows asm eieio assembly.])



#### test if we can use __thread ####
cat > $t <<EOT
__thread unsigned long long int x;
static __thread  int y;
void foo(void)
{
	x = 1;
	y = 1;
}
EOT
test_cxx "whether __thread (Thread Local Storage) is supported" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_TLS_VARIABLES, $strictpass, [Allows __thread.])

#### check __sync_add_and_fetch ####
cat > $tc <<EOT
#include <stdio.h>
int main()
{
  int t=1;
  __sync_add_and_fetch(&t, 1);
  return 1;
}
EOT
test_linkc "whether synchronization primitives (__sync_add_and_fetch) works in C" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_C_SYNC_ADD_AND_FETCH_PRIMITIVE, $pass, [whether sync_add_and_fetch primitive works in C])

#### check __sync_synchronize ####
cat > $tc <<EOT
#include <stdio.h>
int main()
{
  __sync_synchronize();
}
EOT

test_linkc "whether synchronization primitives (__sync_synchronize) works in C" "yes" "no" ""

AC_DEFINE_UNQUOTED(CMK_C_SYNC_SYNCHRONIZE_PRIMITIVE, $pass, [whether sync_synchronize primitives works in C])


#### check __BUILTIN_IA32_XFENCE ####
cat > $tc <<EOT
#include <stdio.h>
#include <intrinsics.h>
int main()
{
  __builtin_ia32_lfence();  __builtin_ia32_sfence();   __builtin_ia32_mfence();
}
EOT

test_linkc "whether fence intrinsic primitives (__builtin_Xfence_ia32) works in C" "yes" "no" ""

AC_DEFINE_UNQUOTED(CMK_C_BUILTIN_IA32_XFENCE, $pass, [whether Xfence intrinsics works in C])


### test if switching TLS register ###
if test $in64bit = 1
then
cat > $t <<EOT
#include <elf.h>
#include <stdlib.h>
#include <malloc.h>

void switchTLS() {
  Elf64_Addr m1, m2;
  asm volatile ("movq %%fs:0x0, %0\n\t"
                "movq %1, %%fs:0x0\n\t"
                : "=r"(m1)
                : "r"(m2));
}
EOT
test_cxx "whether switching TLS register (64-bit) is supported" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_TLS_SWITCHING64, $strictpass, [Allows switching TLS 64-bit.])
else
cat > $t <<EOT
#include <elf.h>
#include <stdlib.h>
#include <malloc.h>

void switchTLS() {
  Elf32_Addr m1, m2;
  asm volatile ("movl %%gs:0x0, %0\n\t"
                "movl %1, %%gs:0x0\n\t"
                : "=r"(m1)
                : "r"(m2));
}
EOT
test_cxx "whether switching TLS register (32-bit) is supported" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_TLS_SWITCHING32, $strictpass, [Allows switching TLS in 32-bit.])
fi

#### test if we can build MPI ####
if test "$CMK_BUILD_MPI" = 1
then

cat > $t <<EOT
#include "mpi.h"
int main(int argc, char **argv)
{
  MPI_Init(&argc, &argv);
}
EOT
mv -f ../include/mpi.h ../include/mpi.h.bak 2>/dev/null
test_cc "whether build on MPI" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_BUILD_ON_MPI, $strictpass, [build MPI.])
BUILD_MPI=$strictpass

if test $BUILD_MPI -eq 0
then
  echo "Error: Can not compile a MPI program"
  test_finish 1
fi

if test $BUILD_MPI -eq 1 -a -z "$BGP_FLOOR"
then
  test_linkc "whether need to specify MPI library" "no" "yes" ""
  if test $pass -ne 1
  then
    if test -z "$CMK_MPI_LIB"
    then
      test_linkc "whether -lmpich" "ok" "no" "-lmpich"
      if test $pass -eq 1
      then
        add_flag CMK_SYSLIBS='"$CMK_SYSLIBS -lmpich"' "mpi lib"
      else
        test_linkc "whether -lmpi" "ok" "no" "-lmpi"
        if test $pass -eq 1
        then
                add_flag CMK_SYSLIBS='"$CMK_SYSLIBS -lmpi"' "mpi lib"
        else
                echo "Error: can not find mpi library"
                test_finish 1
        fi
      fi
    else
      add_flag CMK_SYSLIBS='"$CMK_SYSLIBS $CMK_MPI_LIB"' "mpi lib"
    fi
  fi
fi

if test "$BUILD_MPI" = "1"
then
cat > $t <<EOT
#include "mpi.h"
int main(int argc, char **argv)
{
  int thread_level, provided;
  thread_level = MPI_THREAD_FUNNELED;
  MPI_Init_thread(&argc, &argv, thread_level, &provided);
}
EOT
test_cxx "whether MPI_Init_thread is supported" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_MPI_INIT_THREAD, $strictpass, [Allows MPI_Init_thread.])
fi
mv -f ../include/mpi.h.bak ../include/mpi.h 2>/dev/null

fi

if test "$BUILD_MPI" = "1"
then

cat > $t <<EOT
#include <stdio.h>
#include <mpi.h>

int main (int argc, char** argv) {
  return 0;
}
EOT
test_cxx "whether macro conflicts occurs due to C++ MPI bindings" "no" "yes" ""
AC_DEFINE_UNQUOTED(CMK_CXX_MPI_BINDINGS, $strictpass, [Disables conflicting macros.])
fi


################### Syscalls and Libraries ###################

#### test for getrusage with RUSAGE_THREAD ###
cat > $tc <<EOT
#include <sys/time.h>
#define __USE_GNU   1
#include <sys/resource.h>
int main() {
  struct rusage usage;
  getrusage(RUSAGE_THREAD, &usage);
  return 0;
}
EOT
test_linkc "whether getrusage accepts RUSAGE_THREAD" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_RUSAGE_THREAD, $pass, [whether getrusage accepts RUSAGE_THREAD])

#### test for asctime ###

cat > $tc <<EOT
#include <time.h>
int main() {
  struct tm *local;
  time_t t;
  t = time(NULL);
  local = localtime(&t);
  asctime(local);
  return 0;
}
EOT
test_linkc "whether has asctime" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_ASCTIME, $pass, [whether has asctime])

#### test for log2 ###
cat > $t <<EOT
#include <math.h>
int main() {
  int i = log2(10);
  return 0;
}
EOT
test_link "whether has log2" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_LOG2, $pass, [whether has log2])

#### test for sqrtf ###
cat > $t <<EOT
#include <math.h>
int main() {
  float i = sqrtf((float)10.0);
  return 0;
}
EOT
test_link "whether has sqrtf" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_SQRTF, $pass, [whether has sqrtf])

#### test for fabsf ###
cat > $t <<EOT
#include <math.h>
int main() {
  float i = fabsf((float)10.0);
  return 0;
}
EOT
test_link "whether has fabsf" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_FABSF, $pass, [whether has fabsf])

#### test for mkstemp ###
cat > $t <<EOT
#include <stdlib.h>
#include <string.h>
int main() {
  char fname[[128]];
  strcpy(fname, "/tmp/fdXXX.XXX");
  mkstemp(fname);
  return 0;
}
EOT
test_link "whether has mkstemp" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_USE_MKSTEMP, $pass, [whether has mkstemp])

#### test for system ###
cat > $t <<EOT
#include <stdlib.h>
int main() {
  system("/bin/ls");
  return 0;
}
EOT
test_link "whether has system" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_SYSTEM, $pass, [whether has system])

#### test for sync() ###
cat > $t <<EOT
#include <unistd.h>
int main() {
  sync();
  return 0;
}
EOT
test_link "whether has sync()" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_SYNC_FUNC, $pass, [whether has sync])

#### test for fsync() ###
cat > $t <<EOT
#include <unistd.h>
int main() {
  fsync(0);
  return 0;
}
EOT
test_link "whether has fsync()" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_FSYNC_FUNC, $pass, [whether has fsync])

#### test for fdatasync() ###
cat > $t <<EOT
#include <unistd.h>
int main() {
  fdatasync(0);
  return 0;
}
EOT
test_link "whether has fdatasync()" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_FDATASYNC_FUNC, $pass, [whether has fdatasync])

#### test for sbrk ###
cat > $t <<EOT
#include <unistd.h>
int main() {
  void *ptr  = sbrk(0); 
}
EOT
test_link "whether has sbrk" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_SBRK, $pass, [whether has sbrk])

#### test for _setjmp/_longjmp ###
cat > $t <<EOT
#include <setjmp.h>
int main() {
  jmp_buf buf;
  _setjmp(buf);
  _longjmp(buf, 0);
}
EOT
test_link "whether has _setjmp/_longjmp" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_UNDERSCORE_SETJMP, $pass, [whether has _setjmp/_longjmp])

#### test for mstats ###
cat > $t <<EOT
#include <malloc.h>
int main() {
  struct mstats ms = mstats();
}
EOT
test_link "whether has mstats" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_MSTATS, $pass, [whether has mstats])

#### test for mallinfo ###
cat > $t <<EOT
#include <malloc.h>
int main() {
  struct mallinfo mi = mallinfo();
}
EOT
test_link "whether has mallinfo" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_MALLINFO, $pass, [whether has mallinfo])

#### test for popen ###
cat > $t <<EOT
#include <stdio.h>
int main() {
  FILE *p = popen("/bin/ps", "r");
  pclose(p);
}
EOT
test_link "whether has popen" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_POPEN, $pass, [whether has popen])

#### test for poll ###
cat > $t <<EOT
#include <poll.h>
void foo(void) { 
  struct pollfd pos[[3]];
  poll(pos, 1, 1);
}
EOT
test_cxx "whether has poll" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_USE_POLL, $pass, [whether the poll syscall exists])

#### check if getpagesize exists ####
cat > $tc <<EOT
#include <unistd.h>

int main(int argc, char **argv) {
    int s = getpagesize();
}
EOT
test_linkc "whether has getpagesize" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_GETPAGESIZE, $pass, [whether getpagesize exists])

#### check if getpid exists ####
cat > $tc <<EOT
#include <sys/types.h>
#include <unistd.h>

int main(int argc, char **argv) {
    pid_t pid = getpid();
}
EOT
test_linkc "whether has getpid" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_GETPID, $pass, [whether getpid exists])

#### check if kill exists ####
cat > $tc <<EOT
#include <sys/types.h>
#include <unistd.h>
#include <signal.h>

int main(int argc, char**argv) 
{
    pid_t pid = getpid();
    kill(pid, 9);
}
EOT
test_linkc "whether has kill" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_KILL, $pass, [whether kill exists])

#### test for setpriority ###
cat > $t <<EOT
#include <sys/time.h>
#include <sys/resource.h>
void foo(void) { 
  setpriority(PRIO_PROCESS, 0, 0);
}
EOT
test_cxx "whether has setpriority" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_SETPRIORITY, $pass, [whether the setpriority exists])

#### test for system ###
cat > $t <<EOT
#include "ckdll_system.C"
EOT
test_cxx "whether to use signal-safe system() " "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_SIGSAFE_SYSTEM, $pass, [whether to use signal-safe system()])

### test sched_setaffinity ####
cat > $tc <<EOT
#define _GNU_SOURCE
#include <sched.h>

int main()
{
  cpu_set_t cpuset;
  CPU_ZERO(&cpuset);
  CPU_SET(0, &cpuset);
  if (sched_setaffinity(0, sizeof(cpuset), &cpuset) < 0) {
    return -1;
  }
  return 0;
}
EOT
test_linkc "whether sched_setaffinity call exists" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_SETAFFINITY, $pass, [whether the sched_setaffinity() exists])

### test pthread_setaffinity_np ####
cat > $tc <<EOT
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

int main()
{
  unsigned long mask = 0xffffffff;
  unsigned int len = sizeof(mask);

  if (pthread_setaffinity_np(pthread_self(), len, &mask) < 0) {
    return -1;
  }
  return 0;
}
EOT
test_linkc "whether pthread_setaffinity_np call exists" "yes" "no" "-lpthread"
AC_DEFINE_UNQUOTED(CMK_HAS_PTHREAD_SETAFFINITY, $pass, [whether the pthread_setaffinity_np() exists])

### test pthread_spin_lock ####
cat > $tc <<EOT
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

int main()
{
  pthread_spinlock_t  lock;

  pthread_spin_init(&lock, 0);

  pthread_spin_lock(&lock);

  return 0;
}
EOT
test_linkc "whether pthread_spin_lock exists" "yes" "no" "-lpthread"
AC_DEFINE_UNQUOTED(CMK_HAS_SPINLOCK, $pass, [whether the pthread_spin_lock exists])

### check libnuma on Linux ####
if test "$WITH_NUMA" = "yes"
then
cat > $tc <<EOT
#include <stdlib.h>
#include <stdio.h>
#include <linux/mempolicy.h>
#include <numaif.h>
#include <numa.h>

int main()
{
  if (get_mempolicy(NULL, NULL, 0, 0, 0) == 0) return 0;
  return -1;
}
EOT
test_linkc "whether libnuma exists" "yes" "no" "-lnuma"
AC_DEFINE_UNQUOTED(CMK_HAS_NUMACTRL, $pass, [whether NUMA control related functions exist])
if test $pass -eq 1
then
        add_flag 'CMK_SYSLIBS="$CMK_SYSLIBS -lnuma"' "libnuma"
fi
fi

#### check bindprocessors on AIX ####
cat > $tc <<EOT
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

#include <sys/processor.h>

int main()
{
  int retValue = 0;
  int pid;
  pid = getpid();
  if (bindprocessor(BINDPROCESS, pid, 0) == -1) return -1;
  return 0;
}
EOT
test_linkc "whether bindprocessor call exists" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_BINDPROCESSOR, $pass, [whether the bindprocessor()
exists])


#### check if dlopen works ####
skip_dl=0
# for bproc, ignore -ldl
test -n "$CMK_BPROC" && skip_dl=1
test -n "$CMK_NO_DL" && skip_dl=1
dl_opt='-ldl'
#workaround for pgcc 4.0, -ldl crash linking, so use -Wl,-ldl to skip the prelinker.
case "$CMK_CXX" in
pgCC*) dl_opt='-Wl,-ldl' ;;
esac

if test $skip_dl -eq 0 
then

cat > $t <<EOT
#include "ckdll_dlopen.C"
int main() {
	CkDll dll("foo.so");
	return 0;
}
EOT
test_link "whether dlopen links without $dl_opt" "yes" "no" ""
noldl=$pass
test_link "whether dlopen links with $dl_opt" "yes" "no" "$dl_opt"
if test $pass -eq 1
then 
#dlopen requires -ldl: add it to our link line
	add_flag CMK_LIBS='"$CMK_LIBS '$dl_opt'"' "dlopen"
fi

if test $pass -eq 1 -o $noldl -eq 1
then
# One version or another of dlopen worked: compile it in
	AC_DEFINE_UNQUOTED(CMK_DLL_USE_DLOPEN, 1, [dlopen])
fi

### test gethostname ####
cat > $tc <<EOT
#ifdef WIN32
#include <Winsock2.h>
#else
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#endif

int main()
{
  char hostname[[1000]];
  gethostname(hostname, 999);
  return 0;
}
EOT
test_linkc "whether gethostname call exists" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_GETHOSTNAME, $pass, [whether gethostname() exists])

#### check if getProcAddress works ####
cat > $t <<EOT
#include "ckdll_win32.C"
EOT
test_cxx "whether getProcAddress works" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_DLL_USE_WIN32, $pass, [whether getProcAddress works])

fi    # end of skip_dl

#### check if socklen_t exists ####
cat > $t <<EOT
#include <sys/types.h>
#include <sys/socket.h>

void foo(void) {
	int i;
	socklen_t s=sizeof(i);
}
EOT
test_cxx "whether has socklen_t" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_SOCKLEN, $pass, [whether has socklen_t])

### test getifaddrs ####
cat > $tc <<EOT
#include <netinet/in.h> /* for sockaddr_in */
#include <ifaddrs.h> /* for getifaddrs */
#include <net/if.h> /* for IFF_RUNNING */

int main()
{
  struct ifaddrs *interfaces=0;
  if( getifaddrs(&interfaces) == 0 ) {
        struct ifaddrs *interface;
        for( interface=interfaces; interface; interface=interface->ifa_next ) {
            if( (interface->ifa_flags & IFF_UP) && ! (interface->ifa_flags & IFF_LOOPBACK) ) {
                const struct sockaddr_in *addr = (const struct sockaddr_in*)interface->ifa_addr;
                if( addr && addr->sin_family==AF_INET ) {
                    break;
                }
            }
        }
        freeifaddrs(interfaces);
  }
}
EOT
test_linkc "whether getifaddrs call exists" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_GETIFADDRS, $pass, [whether getifaddrs() exists])

#### check if mmap exists ####
cat > $t <<EOT
#include <sys/types.h>
#include <sys/mman.h>

void *foo(void *a,int l,int fd) {
	return mmap((caddr_t)a,l,PROT_READ+PROT_WRITE,
                 MAP_FIXED+MAP_PRIVATE,fd,0);
}
EOT
test_cxx "whether the mmap() syscall exists" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_MMAP, $pass, [whether the mmap() syscall exists])

#### check if mmap accepts MAP_ANON ####
cat > $t <<EOT
#include <sys/types.h>
#include <sys/mman.h>

void *foo(void *a,int l) {
	return mmap((caddr_t)a,l,PROT_READ+PROT_WRITE,
                MAP_FIXED+MAP_PRIVATE+MAP_ANON,-1,0);
}
EOT
test_cxx "whether mmap() accepts MAP_ANON" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_MMAP_ANON, $pass, [whether mmap() accepts MAP_ANON])

#### check if mmap accepts MAP_NORESERVE ####
cat > $t <<EOT
#include <sys/types.h>
#include <sys/mman.h>

void *foo(void *a,int l) {
	return mmap((caddr_t)a,l,PROT_READ+PROT_WRITE,
                MAP_FIXED+MAP_PRIVATE+MAP_NORESERVE,-1,0);
}
EOT
test_cxx "whether mmap() accepts MAP_NORESERVE" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_MMAP_NORESERVE, $pass, [whether mmap() accepts MAP_NORESERVE])

#### check if get_myaddress exists ####
cat > $t <<EOT
#include <rpc/rpc.h>

void foo(void *a) {
    get_myaddress((struct sockaddr_in*)a);
}
EOT
test_cxx "whether has get_myaddress" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_GET_MYADDRESS, $pass, [whether has get_myaddress])

#### check if mprotect exists ####
cat > $t <<EOT
#include <stdio.h>
#include <sys/mman.h>

void foo(void *a,int l,int fd) {
     void *pg = NULL;
     size_t pagesize = 4096;
     mprotect(pg, pagesize, PROT_READ | PROT_WRITE);
}
EOT
test_cxx "whether has mprotect" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_MPROTECT, $pass, [whether has mprotect])

#### check if glibc backtrace exists ####
cat > $t <<EOT
#include "cmibacktrace.c"

int main() {
	int nLevels=1;
	void *stack;
	CmiBacktraceRecord(&stack,0,&nLevels);
	return 0;
}
EOT
TRACE_LINK_FLAG="-rdynamic"
test_link "whether glibc backtrace works" "yes" "no" "-DCMK_USE_BACKTRACE=1 $TRACE_LINK_FLAG"
AC_DEFINE_UNQUOTED(CMK_USE_BACKTRACE, $pass, [whether glibc backtrace works])

if test $strictpass -eq 1
then 
	add_flag 'CMK_LD="$CMK_LD '$TRACE_LINK_FLAG'"' "backtrace"
	add_flag 'CMK_LDXX="$CMK_LDXX '$TRACE_LINK_FLAG'"' "backtrace"
fi

#### test sleep ####
cat > $t <<EOT
#include <unistd.h>
int main() {
  sleep(1);
  return 0;
}
EOT
test_cxx "whether has sleep " "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_SLEEP, $pass, [whether has sleep])

#### test usleep ####
cat > $t <<EOT
#include <unistd.h>
int main() {
  usleep(100);
  return 0;
}
EOT
test_cxx "whether has usleep " "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_USLEEP, $pass, [whether has usleep])

#### test personality() and ADDR_NO_RANDOMIZE ####
# Only works on modern Linux systems
cat > $t <<EOT
#include <sys/personality.h>
int main() {
    int orig_persona = personality(0xffffffff);
    personality(orig_persona | ADDR_NO_RANDOMIZE);
    return 0;
}
EOT
test_cxx "whether personality() and ADDR_NO_RANDOMIZE exist" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_ADDR_NO_RANDOMIZE, $pass, [whether personality() and ADDR_NO_RANDOMIZE exist])


#### test if has zlib ####
# bproc doesnot like -lz in any case
if test -z "$CMK_BPROC"
then

cat > $t <<EOT
#include <zlib.h>
int main() { 
  gzFile f = gzopen("/tmp/x","r");
  gzprintf(f, "test...\n");
  gzclose(f);
  return 0;
}
EOT
test_link "whether has zlib" "yes" "no" "-lz"
AC_DEFINE_UNQUOTED(CMK_PROJECTIONS_USE_ZLIB, $pass, [whether has zlib])
if test $pass -eq 1
then 
	add_flag 'CMK_LIBZ="-lz"' "zlib"
fi

fi

#### test if has elf.h ####
cat > $t <<EOT
#include <elf.h>
typedef Elf32_Addr ELF_TYPE_Addr;
int main() { 
}
EOT
test_cxx "whether has elf.h " "yes" "no" ""
AC_DEFINE_UNQUOTED([CMK_HAS_ELF_H], $pass, [whether has elf.h])

#### test if has Multiprocessing.h for apple ####
cat > $t <<EOT
#include <Carbon/Carbon.h>
#include <Multiprocessing.h>
int main() {
  int a = MPProcessorsScheduled();
}
EOT
test_cxx "whether has Multiprocessing.h for Apple " "yes" "no" ""
AC_DEFINE_UNQUOTED([CMK_HAS_MULTIPROCESSING_H], $pass, [whether has Multiprocessing.h])

#### test if "ntohl" is available ####
cat > $t <<EOT
#if defined(_WIN32) && ! defined(__CYGWIN__) || defined(__MINGW_H)
#include <winsock.h>
#else
#include <stdint.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#endif

int main() {
  int i = 100;
  i = ntohl(i);
  return 0;
}
EOT
test_link "whether ntohl is available" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_NTOHL, $pass, [whether ntohl is available])

### test for libjpeg ####
cat > $t <<EOT
#include <stdio.h>
#include <stdlib.h>
#include "jpeglib.h"

int main()
{
  struct jpeg_compress_struct cinfo;
  jpeg_create_compress(&cinfo);
  return 0;
}
EOT
test_link "whether has libjpeg" "yes" "no" "-ljpeg"
AC_DEFINE_UNQUOTED(CMK_USE_LIBJPEG, $pass, [whether has libjpeg])
if test $pass -eq 1
then
        add_flag 'CMK_LIBJPEG="-ljpeg"' "libjpeg"
fi

#### check if PAPI exists ####
if test -n "$CMK_USE_PAPI"
then
cat > $t <<EOT
#include <stdio.h>
#include <papi.h>
                                                                                
int main() {
    if (PAPI_library_init(PAPI_VER_CURRENT) != PAPI_VER_CURRENT) return 1;
    return 0;
}
EOT
test_link "whether PAPI exists" "yes" "no" "-lpapi"
AC_DEFINE_UNQUOTED(CMK_HAS_COUNTER_PAPI, $pass, [whether PAPI exists])
if test $pass -eq 1
then 
	add_flag 'CMK_LIBS="$CMK_LIBS -lpapi"' "papi"
fi
fi

#### test if Python headers are installed ####
PYTHON_VERSION=`python -V 2>&1 | awk {'print $2'} | awk -F. {'print $1"."$2'}`
cat > $t <<EOT
#include "python${PYTHON_VERSION}/Python.h"
#include "python${PYTHON_VERSION}/compile.h"
#include "python${PYTHON_VERSION}/eval.h"
#include "python${PYTHON_VERSION}/node.h"

int main() {
    Py_Initialize();
    PyEval_InitThreads();
    struct _node* programNode = PyParser_SimpleParseString("return 1\n",Py_file_input);
    PyCodeObject *program = PyNode_Compile(programNode, "");
}
EOT
test_link "whether Python is installed" "yes" "no" "-lpython$PYTHON_VERSION -lpthread -lutil -ldl"
AC_DEFINE_UNQUOTED(CMK_HAS_PYTHON, $pass, [whether Python is installed])
AC_DEFINE_UNQUOTED(CMK_PYTHON_VERSION, ${PYTHON_VERSION}, [Python version])
if test $pass -eq 1
then
	add_flag "CMK_BUILD_PYTHON=$PYTHON_VERSION" "python"
fi

#### Pick up METIS if the user asks for it ####

AC_ARG_WITH([metis],
	    [AS_HELP_STRING([--with-metis],
	     [support the METIS graph partitioner and associated load balancer])],
	    [],
	    [with_metis=no])

WITH_METIS=no
if test "$with_metis" != "no"
then
  Echo "Compiling Charm with support for METIS"
  WITH_METIS=yes
  echo 'charm++: $(L)/libmoduleMetisLB.a $(L)/libmoduleTeamLB.a' >> $MAKEFILE_EXT
  add_flag 'CMK_LIBS="$CMK_LIBS -lmetis"' "libmetis"
  if test "$with_metis" != "yes"
  then
    add_flag "CMK_METIS=$with_metis" "Where to find METIS"
    add_flag 'CMK_LIBDIR="$CMK_LIBDIR -L$CMK_METIS"' "Library path for METIS"
    if test -r $with_metis/Lib/metis.h
    then
      add_flag 'CMK_INCDIR="$CMK_INCDIR -I$CMK_METIS/Lib"' "Include path for METIS 4"
    elif test -r $with_metis/../include/metis.h
    then
      add_flag 'CMK_INCDIR="$CMK_INCDIR -I$CMK_METIS/../include"' "Include path for METIS 5"
    else
      echo "I can't find metis.h, since the path you specified (which should point to the directory containing libmetis.a) is not laid out as I expect for version 4 or 5."
      test_finish 1
    fi
  fi
fi

## Cray specific test
if test "$CMK_BUILD_CRAY" = "1"
then
#echo "Test for known incompatible compiler versions"

 if test "$CRAY_CC_VERSION" = "8.1.4"
 then
	echo "CCE 8.1.4 produces incorrect Charm++ code"
	echo "Please use a newer version of the CCE compiler"
	echo "e.g. module load cce/8.1.7"
	test_finish 1
 fi

#### test if Cray node topology will work ####
cat > $tc <<EOT
#include <pmi.h>

int main() {
    int nid;
    PMI_Get_nid(0, &nid);

    return 0;
}
EOT
test_linkc "whether PMI_Get_nid exists" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_PMI_GET_NID, $pass, [whether PMI_Get_nid exists])

#### test if Cray mesh topology will work ####
cat > $tc <<EOT
#include <rca_lib.h>

int main() {
    rca_mesh_coord_t xyz;
    rca_get_meshcoord(0, &xyz);

    return 0;
}
EOT
test_linkc "whether Cray rca library is available" "yes" "no" "$CRAY_RCA_POST_LINK_OPTS -lrca"
AC_DEFINE_UNQUOTED(CMK_HAS_RCALIB, $pass, [whether Cray rca library is available])

#### test if Cray mesh dimension query function will work ####
cat > $tc <<EOT
#include <rca_lib.h>

int main() {
    rca_mesh_coord_t xyz;
    rca_get_max_dimension(&xyz);

    return 0;
}
EOT
test_linkc "whether Cray rca_has get_max_dimension" "yes" "no" "$CRAY_RCA_POST_LINK_OPTS -lrca"
AC_DEFINE_UNQUOTED(CMK_HAS_RCA_MAX_DIMENSION, $pass, [whether Cray rca has rca_get_max_dimension])

#### query Cray machine max NID if get_max_dimension not exist ####

if test $pass -eq 0
then
cmd=`which xtprocadmin 2>/dev/null`
if test -n "$cmd"
then
    #maxnid=`xtprocadmin  | tail -1  | awk '{print $1}'`
    # workaround for hopper
    (export SHELL=/bin/csh; xtprocadmin >& t.$$)
    maxnid=`cat t.$$  | tail -1  | awk '{print $1}'`
    /bin/rm -f t.$$
    AC_MSG_CHECKING(Cray machine maxnid)
    AC_MSG_RESULT("$maxnid")
    if test -n "$maxnid"
    then
    AC_DEFINE_UNQUOTED(CMK_CRAY_MAXNID, $maxnid, [Cray MAXNID])
    fi
fi
fi




#### query Cray machine supports BANDWIDTH_INJECTION controls####

if test "$CMK_BUILD_MPI" = "1"
then
echo "BALANCED_INJECTION test disabled on MPI"
elif test "$GNI_CRAYXC" = "1"
then
echo "BALANCED_INJECTION test disabled on Aries network"
else
cat > $tc <<EOT
#include <stdint.h>
#include <gni_pub.h>

int main() {
    gni_bi_desc_t gni_bi_desc;
    uint32_t gni_device_id = 0;
    gni_return_t gni_rc = GNI_GetBIConfig(gni_device_id, &gni_bi_desc);
    if (gni_rc == GNI_RC_SUCCESS) {
    }
    return 0;
}
EOT
test_linkc "whether GNI_GetBIConfig exists" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_BALANCED_INJECTION_API, $pass, [whether Cray gni_pub has GNI_GetBIConfig])
fi # end of BIConfig test


fi  # end of Cray specific test

#### test if it can build shared library ####
cat > $t <<EOT
#include "stdlib.h"
extern int foo();
int foo1() { 
  void * t= malloc(2);
  foo();
  return 0;
}
EOT
test_linkso "whether can build shared library" "yes" "no" ""
if test $pass -eq 0
then 
	add_flag 'CMK_NO_BUILD_SHARED="true"' "build-shared"
else
	BUILD_SHARED=1
        if test "$BUILD_MPI" = "1"
	then
cat > $t <<EOT
#include "stdlib.h"
#include "mpi.h"
extern int foo();
int foo(int argc, char ** argv) {
  void * t= malloc(2);
  foo();
  MPI_Init(&argc, &argv);
  return 0;
}
EOT
		test_linkso "whether can build shared library with MPI" "yes" "no" ""
		BUILD_SHARED=$pass
	fi
	if test $BUILD_SHARED -eq 0
	then
		add_flag 'CMK_NO_BUILD_SHARED="true"' "build-shared"
	fi
fi

#### test the version number of bproc ####
if test -n "$CMK_BPROC"
then
cat > $t <<EOT
#include <stdio.h>
#include <sys/bproc.h>
int main()
{
  struct bproc_version_t vers;
  bproc_version(&vers);
  printf("%s\n", vers.version_string);
}
EOT
test_link "whether bproc compiles" "yes" "no" "-lbproc"
if test $pass -eq 1
then 
AC_MSG_CHECKING("bproc version")
bproc_ver=`./testlink`
if test x$bproc_ver = x
then
test_result 0 "bproc version" "ERROR" ""
test_finish 1
else
test_result 0 "bproc version" "$bproc_ver" ""
fi
bproc_ver=`echo $bproc_ver | cut -d'.' -f1`
AC_DEFINE_UNQUOTED(CMK_BPROC_VERSION, $bproc_ver, [bproc version])
fi
fi

#### test the if command sync exists ####
AC_CHECK_PROG(SYNC, sync, sync )
if test -n "$SYNC"
then
AC_DEFINE_UNQUOTED(CMK_HAS_SYNC, 1, [sync program])
fi

################## Fortran #########################

#echo "set F77 compiler as: $CMK_CF77"
AC_MSG_CHECKING("F77 compiler as")
AC_MSG_RESULT("$CMK_CF77")

AC_MSG_CHECKING("whether Fortran 77 compiler works")
### test fortran 77 compiler ###
cat > conftest.f <<EOF
      SUBROUTINE FOO_foo
      END
EOF
$CMK_CF77 -c conftest.f > /dev/null 2> /dev/null
if test ! -r conftest.o
then
  AC_MSG_RESULT("no")
else
  AC_MSG_RESULT("yes")
fi

### test fortran 90 compiler ###
#echo "set F90 compiler as: $CMK_CF90"
AC_MSG_CHECKING("F90 compiler as")
AC_MSG_RESULT("$CMK_CF90")

AC_MSG_CHECKING("whether Fortran 90 compiler works")
cat > conftest2.f90 <<EOF
      SUBROUTINE FOO_foo
      END
EOF
$CMK_CF90 -c conftest2.f90 > /dev/null 2> /dev/null
if test ! -r conftest2.o
then
  AC_MSG_RESULT("no")
else
  AC_MSG_RESULT("yes")
  mv -f conftest2.o conftest.o
  USE_FORTRAN90=1
fi

### check fortran name mangling
AC_MSG_CHECKING(subroutine name used by Fortran 90 compiler)

if test -r conftest.o
then
  AC_CACHE_VAL(_cv_fortran_postfix,

  NAME=`$CMK_NM conftest.o | grep "foo_foo__"`
  if test "$NAME" != ""
  then
    _cv_fortran_postfix=TWOSCORE
    AC_DEFINE_UNQUOTED(CMK_FORTRAN_USES_TWOSCORE, 1, [TWOSCORE])
  else
    NAME=`$CMK_NM conftest.o | grep "foo_foo_"`
    if test "$NAME" != ""
    then
      _cv_fortran_postfix=ONESCORE
      AC_DEFINE_UNQUOTED(CMK_FORTRAN_USES_ONESCORE, 1, [ONESCORE])
    else
      NAME=`$CMK_NM conftest.o | grep "foo_foo"`
      if test "$NAME" != ""
      then
        _cv_fortran_postfix=NOSCORE
        AC_DEFINE_UNQUOTED(CMK_FORTRAN_USES_NOSCORE, 1, [NOSCORE])
      else
        NAME=`$CMK_NM conftest.o | grep "FOO_FOO"`
        if test "$NAME" != ""
        then
          _cv_fortran_postfix=ALLCAPS
          AC_DEFINE_UNQUOTED(CMK_FORTRAN_USES_ALLCAPS, 1, [ALLCAPS])
        else
          echo "#################################################"
          echo "FORTRAN compiler generated name not supported yet"
          echo "#################################################"
        fi
      fi
    fi
  fi
  rm -f conftest.f conftest.o
  )
  AC_MSG_RESULT($_cv_fortran_postfix)
else
  AC_MSG_RESULT("Fortran compiler not working")
fi

### check module name ###

if test "$USE_FORTRAN90" = 1
then
  cat > conftest.f90 <<EOF
      MODULE testmod
        interface 
          function fpup_issizing(p)
          INTEGER :: p
          logical fpup_issizing
          end function
        end interface
      END MODULE
EOF
  AC_MSG_CHECKING(Fortran 90 mod name is capital)
  $CMK_CF90 -c conftest.f90 > /dev/null 2> /dev/null
  name=`ls TESTMOD.* 2>/dev/null`
  if test -n "$name"
  then
        AC_MSG_RESULT("yes")
	add_flag 'CMK_MOD_NAME_ALLCAPS=1' "mod name capital"
  else
        AC_MSG_RESULT("no")
	name=`ls testmod.* 2>/dev/null`
  fi
  if test -n "$name"
  then
  	AC_MSG_CHECKING(Fortran 90 mod name extension)
    	ext=`echo $name | sed -e 's/^[[^.]]*\.//'`
	add_flag 'CMK_MOD_EXT="'$ext'"' "mod name extension"
        AC_MSG_RESULT("$ext")
        /bin/rm -f $name
  fi
  /bin/rm -f conftest.f90
fi

AC_OUTPUT(
libs/ck-libs/ampi/ampiCC,

chmod +x libs/ck-libs/ampi/ampiCC
)
