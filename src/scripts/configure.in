
AC_INIT(./Makefile)

AC_CONFIG_HEADER(conv-autoconfig.h)

CHARMINC="."
test -r ./conv-config.sh && . ./conv-config.sh

# Decimal representation of Charm++ release line and API revision
# Increment the last 2 digits when making an API change
# Increase the first three after branching for a release
VERSION=60301
echo $VERSION > ../include/VERSION
AC_DEFINE_UNQUOTED([CHARM_VERSION], $VERSION, [Charm++ Release/API version number])

charmout="charmconfig.out"
/bin/rm -rf $charmout

Echo() {
	echo $* 
	echo $* >> $charmout
}

# enable/disable error checking
AC_ARG_ENABLE([error-checking],
            [AS_HELP_STRING([--enable-error-checking],
              [enable error checking])], ,
            [enable_error_checking=yes])

if test "$enable_error_checking" = "no"
then
  Echo "Error checking is disabled" 
  AC_DEFINE_UNQUOTED(CMK_ERROR_CHECKING, 0, [disable error checking])
else
  AC_DEFINE_UNQUOTED(CMK_ERROR_CHECKING, 1, [enable error checking])
fi

# check enable/disable
AC_ARG_ENABLE([tracing],
            [AS_HELP_STRING([--enable-tracing],
              [enable tracing modules])], ,
            [enable_tracing=yes])

if test "$enable_tracing" = "no"
then
  Echo "Charm tracing is disabled"
  AC_DEFINE_UNQUOTED(CMK_TRACE_ENABLED, 0, [disable tracing])
else
  AC_DEFINE_UNQUOTED(CMK_TRACE_ENABLED, 1, [enable tracing])
fi

AC_ARG_ENABLE([charmdebug],
            [AS_HELP_STRING([--enable-charmdebug],
              [enable charmDebug])], ,
            [enable_charmdebug=yes])

if test "$enable_charmdebug" = "no"
then
  Echo "CharmDebug is disabled" 
  AC_DEFINE_UNQUOTED(CMK_CHARMDEBUG, 0, [disable charmdebug])
else
  AC_DEFINE_UNQUOTED(CMK_CHARMDEBUG, 1, [enable charmdebug])
fi

AC_ARG_ENABLE([replay],
            [AS_HELP_STRING([--enable-replay],
              [enable record/replay])],
            [enable_replay=$enableval],
            [enable_replay=yes])

if test "$enable_replay" = "no"
then
  Echo "Charm record/replay is disabled"
  AC_DEFINE_UNQUOTED(CMK_REPLAYSYSTEM, 0, [disable replay])
fi

AC_ARG_ENABLE([controlpoint],
            [AS_HELP_STRING([--enable-controlpoint],
              [enable control point])],
            [enable_controlpoint=$enableval],
            [enable_controlpoint=yes])

if test "$enable_controlpoint" = "yes"
then
  AC_DEFINE_UNQUOTED(CMK_WITH_CONTROLPOINT, 1, [enable controlpoint])
else
  Echo "Charm control point is disabled"
  AC_DEFINE_UNQUOTED(CMK_WITH_CONTROLPOINT, 0, [disable controlpoint])
fi

AC_ARG_WITH([numa],
            [AS_HELP_STRING([--with-numa],
              [support memory affinity with NUMA])],
            [],
            [with_numa=no])

WITH_NUMA=no
if test "$with_numa" = "yes"
then
  Echo "Charm NUMA support is builtin"
  WITH_NUMA=yes
fi
          

#
AC_MSG_CHECKING(machine name)
version=`pwd | awk -F/ '{print $(NF-1)}'`
base_version=`cat .vdir`
AC_DEFINE_UNQUOTED(CMK_MACHINE_NAME, "$version",[machine name])
AC_MSG_RESULT($version)
AC_SUBST(base_version)

t="test.cpp"
tc="test.c"

# test result passed in $1
# If the test suceeded, print $3 and set "pass"/clear "fail"
# If the test failed, print $2 and clear "pass"/set "fail"
test_result() {
	if test $1 -eq 0
	then
                AC_MSG_RESULT("$3")
		pass="1"
		fail="0"
	else
                AC_MSG_RESULT("$4")
		pass="0"
		fail="1"
# For debugging the configure script, just "export autoconf_debug=1"
#  to get this verbose data on any failed tests:
		if test ! -z "$autoconf_debug"
		then
			echo "------- test script for $2 failed:"
			cat out
			echo "------- the test program was:"
			cat $t
			echo "-------"
		fi
	fi
}

# Test: tries to compile C file $t (described by $1).
#  If successful, prints $2 and sets $pass/clears $fail
#  If failure, prints $3 and sets $pass/clears $fail
#  additional arguments to c++ compiler are passed as $4
test_cc() {
        AC_MSG_CHECKING("$1")
	echo "### $1" >> $charmout
	cat $tc >> $charmout
	echo $CMK_CC -I../include -I. $CMK_LIBDIR $CMK_INCDIR $OPTS_CC $OPTS_LD -c $tc -o test.o $4 >> $charmout
	$CMK_CC -I../include -I. $CMK_LIBDIR $CMK_INCDIR $OPTS_CC $OPTS_LD -c $tc -o test.o $4 > out 2>&1
	test_result $? "$1" "$2" "$3"
 	strictpass=$pass
	strictfail=$fail
        if test $pass -eq 1
	then 
 	  if cat out | grep -i "warn" > /dev/null 2>&1
	  then 
	    strictpass="0" && strictfail="1"
          fi
        fi
	cat out >> $charmout
	/bin/rm -f out
}

# Test: tries to compile C++ file $t (described by $1).
#  If successful, prints $2 and sets $pass/clears $fail
#  If failure, prints $3 and sets $pass/clears $fail
#  additional arguments to c++ compiler are passed as $4
test_cxx() {
        AC_MSG_CHECKING("$1")
	echo "### $1" >> $charmout
	cat $t >> $charmout
	echo $CMK_CXX -I../include -I. $CMK_LIBDIR $CMK_INCDIR $OPTS_CXX $OPTS_LD -c $t -o test.o $4 >> $charmout
	$CMK_CXX -I../include -I. $CMK_LIBDIR $CMK_INCDIR $OPTS_CXX $OPTS_LD -c $t -o test.o $4 > out 2>&1
	test_result $? "$1" "$2" "$3"
 	strictpass=$pass
	strictfail=$fail
        if test $pass -eq 1
	then 
 	  if cat out | grep -i "warn" > /dev/null 2>&1
	  then 
	    strictpass="0" && strictfail="1"
          fi
        fi
	cat out >> $charmout
	/bin/rm -f out
}

# Testlink: tries to compile and link a C++ file $t (described by $1).
#  If successful, prints $2 and sets $pass/clears $fail
#  If failure, prints $3 and sets $pass/clears $fail
#  additional arguments to c++ compiler are passed as $4
test_link() {
        AC_MSG_CHECKING("$1")
	echo "### $1" >> $charmout
	cat $t >> $charmout
	echo $CMK_CXX -I../include -I. $CMK_INCDIR $OPTS_CXX -c $t -o test.o $4 >> $charmout
	$CMK_CXX -I../include -I. $CMK_INCDIR $OPTS_CXX -c $t -o test.o $4 > out 2>&1
        if test $? -ne 0
        then
          test_result 1 "$1" "$2" "$3"
        else
          echo $CMK_LDXX -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $4 >> $charmout
          $CMK_LDXX -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $4 >> out 2>&1
          ret=$?
	  test ! -x testlink && ret=1
          test_result $ret "$1" "$2" "$3"
        fi
 	strictpass=$pass
	strictfail=$fail
        if test $pass -eq 1
	then 
 	  if cat out | grep -i "warn" > /dev/null 2>&1
	  then 
	    strictpass="0" && strictfail="1"
          fi
        fi
	cat out >> $charmout
	/bin/rm -f out
}

# Testlinkc: tries to compile and link a C file $t (described by $1).
#  If successful, prints $2 and sets $pass/clears $fail
#  If failure, prints $3 and sets $pass/clears $fail
#  additional arguments to c++ compiler are passed as $4
test_linkc() {
        AC_MSG_CHECKING("$1")
	echo "### $1" >> $charmout
	cat $tc >> $charmout
	echo $CMK_CC -I../include -I. $CMK_INCDIR $OPTS_CC -c $tc -o test.o $4 >> $charmout
	$CMK_CC -I../include -I. $CMK_INCDIR $OPTS_CC -c $tc -o test.o $4 > out 2>&1
        if test $? -ne 0
        then
          test_result 1 "$1" "$2" "$3"
        else
          echo $CMK_LD -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $4 >> $charmout
          $CMK_LD -o testlink test.o $CMK_LIBDIR $OPTS_LD $CMK_SYSLIBS $4 >> out 2>&1
          test_result $? "$1" "$2" "$3"
        fi
 	strictpass=$pass
	strictfail=$fail
        if test $pass -eq 1
	then 
 	  if cat out | grep -i "warn" > /dev/null 2>&1
	  then 
	    strictpass="0" && strictfail="1"
          fi
        fi
	cat out >> $charmout
	/bin/rm -f out
}

# test_linkso $1 $2 $3 $4, where
# $1: debug msg
# $2: yes msg
# $3: no msg
# $4: extra link option
test_linkso() {
        AC_MSG_CHECKING("$1")
	echo $1 >> $charmout
	cat $t >> $charmout
	echo $CMK_CXX -I../include -I. $CMK_INCDIR $OPTS_CXX -c $t -o test.o $4 >> $charmout
	$CMK_CXX -I../include -I. $CMK_INCDIR $OPTS_CXX -c $t -o test.o $4 > out 2>&1
        if test $? = 1
        then
          test_result 1 "$1" "$2" "$3"
        else
	  echo $CMK_LD -I../include -I. $CMK_LIBDIR $OPTS_LD $CMK_LD_SHARED test.o -o testlink.$CMK_SHARED_SUF $4 >> $charmout
	  $CMK_LD -I../include -I. $CMK_LIBDIR $OPTS_LD $CMK_LD_SHARED test.o -o testlink.$CMK_SHARED_SUF $4 > out 2>&1
	  test_result $? "$1" "$2" "$3"
	fi
	cat out >> $charmout
	/bin/rm -f out testlink.$CMK_SHARED_SUF
}

# add into conv-mach-opt.sh
# add_flag $1 $2
# $2 is description
add_flag() {
        key=`echo $1 | cut -d'=' -f1`
        last=`grep $key ../include/conv-mach-opt.sh 2>/dev/null | tail -1`
        skip=0
	if test -n "$last" -a  "$last" = "$1" 
	then
	  skip=1
        fi
	if test $skip = 0
        then
	  cat >> ../include/conv-mach-opt.sh << EOT

# Option added by configure script's $2 section
$1

EOT
	fi
}

test_finish() {
	rm -f $t $tc testlink test.o	> /dev/null 2>&1
	/bin/rm -f out
	test $1 -eq 1 && echo "*** Please find detailed output in charmconfig.out ***"
	exit $1
}

# detect certain architectures
if cat /proc/cpuinfo 2>/dev/null | grep 'POWER7'  > /dev/null
then
  AC_DEFINE_UNQUOTED(CMK_POWER7, 1, [whether is power7])
fi

# detect OS
OSNAME=`uname -s`
if test $OSNAME = "Linux"
then
  AC_DEFINE_UNQUOTED(CMK_OS_IS_LINUX, 1, [OS is Linux])
else
  AC_DEFINE_UNQUOTED(CMK_OS_IS_LINUX, 0, [OS is Linux])
fi

# test cp -p
AC_MSG_CHECKING("cp command as")
CP="cp -p"
touch test_file
if ! $CP test_file test_file.cp 2>err
then
  CP="cp"
fi
rm -f test_file test_file.cp
AC_MSG_RESULT($CP)
add_flag CP=\""$CP"\" "cp command"
 

# try to decide the version of glibc
get_glibc_version() {
t=test.c
cat > $t <<EOT
#include <stdio.h>
#include <gnu/libc-version.h>
int main (void) { puts (gnu_get_libc_version ()); return 0; }
EOT
gcc -o gver test.c
GLIBCVERSION=`./gver`
/bin/rm -f $t gver
}

cat > $t <<EOT
#include <stdio.h>
void foo(void) {
	printf("Hello, world!\n");
}
EOT
#echo "set C++ compiler as: $CMK_CXX $OPTS_CXX $OPTS"
AC_MSG_CHECKING("C++ compiler as")
AC_MSG_RESULT("$CMK_CXX $OPTS_CXX $OPTS")
test_cxx "whether C++ compiler works" "ok" "no" ""
if test $fail -eq 1
then
	echo "Cannot compile C++ programs with $CMK_CXX"
	echo " (check your charm++ version)"
	test_finish 1
fi

cat > $t <<EOT
#include <stdio.h>
int main() {
	printf("Hello, world!\n");
	return 0;
}
EOT
#echo "set C++ linker as: $CMK_LDXX $OPTS_LDXX"
AC_MSG_CHECKING("C++ linker as")
AC_MSG_RESULT("$CMK_LDXX $OPTS_LDXX")
test_link "whether linker works" "ok" "no" ""
if test $fail -eq 1
then
	echo "Cannot link C++ programs with $CMK_LDXX"
	echo " (check your charm++ version)"
	test_finish 1
fi

if test "$base_version" = "net-linux" 
then
  test_link "whether linker accept --allow-multiple-definition" "ok" "no" "-Wl,--allow-multiple-definition"
  if test $pass -eq 1
  then
	add_flag CMK_LDXX='"$CMK_LDXX -Wl,--allow-multiple-definition"' "net-linux linker"
  fi
fi

# Perform the tests

#### Check if compiler if 64 bit ####
cat > $t <<EOT
#include <stdio.h>

int foo()
{
int x[[sizeof(void *) - 7]]={0};
return x[[0]];
}
EOT
test_cxx "whether compiler is 64bit" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_SIZET_64BIT, $strictpass, [whether size_t 64bit])
in64bit=$strictpass


#### check strings.h ####
cat > $t <<EOT
#include <strings.h>
int main() { 
  char str[[8]];
  bzero(str, 8);
  return 0;
}
EOT
test_cxx "whether has strings.h " "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_STRINGS_H, $pass, [whether has strings.h])

#### test if has values.h ####
cat > $t <<EOT
#include <values.h>
int main() { 
  double d = MAXDOUBLE;
  return 0;
}
EOT
test_cxx "whether has values.h " "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_VALUES_H, $pass, [whether has values.h])

#### test if has stdint.h ####
cat > $t <<EOT
#include <stdint.h>
int main() { 
  return 0;
}
EOT
test_cxx "whether has stdint.h " "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_STDINT_H, $pass, [whether has stdint.h])

#### test if has malloc.h ####
cat > $t <<EOT
#include <malloc.h>
int main() { 
  return 0;
}
EOT
test_cxx "whether has malloc.h " "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_MALLOC_H, $pass, [whether has malloc.h])

#### test if has alloca.h ####
cat > $t <<EOT
#include <alloca.h>
int main() {
  double *s=(double *)alloca(sizeof(double));
  *s=1.0;
  return 0;
}
EOT
test_cxx "whether has alloca.h " "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_ALLOCA_H, $pass, [whether has alloca.h])

#### test if has regex.h ####
cat > $t <<EOT
#include <regex.h>
int main() {
  regex_t re;
  regcomp(&re, ".*MOD.*", REG_EXTENDED|REG_NOSUB);
  return 0;
}
EOT
test_cxx "whether has regex.h " "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_REGEX_H, $pass, [whether has regex.h])

#### Check bool ####
cat > $t <<EOT
#include <stdlib.h>
bool foo(void) { return true; }
EOT
test_cxx "whether C++ bool works" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_BOOL_DEFINED, $pass, [whether C++ bool works])

#### Check long long ####
cat > $t <<EOT
#include <stdlib.h>
long long foo(void) { return 17; }
EOT
test_cxx "whether long long works" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_LONG_LONG_DEFINED, $pass, [whether long long works])

#### Check __int64 ####
cat > $t <<EOT
#include <stdlib.h>
__int64 foo(void) { return 17; }
EOT
test_cxx "whether __int64 works" "ok" "no" ""
AC_DEFINE_UNQUOTED([CMK___int64_DEFINED], $pass, [whether __int64 works])

#### Check long double ####
cat > $t <<EOT
#include <stdlib.h>
long double foo(void) { return 17.0; }
EOT
test_cxx "whether long double works" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_LONG_DOUBLE_DEFINED, $strictpass, [whether long double works])

#### Check ucontext and FPU pointer ####
cat > $t <<EOT
#include <ucontext.h>
struct _libc_fpstate   fpstate;
fpregset_t *fp;
EOT
test_cxx "whether ucontext has FPU pointer" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_CONTEXT_FPU_POINTER, $pass, [whether ucontext has pointer])

if test $pass -eq 1
then
cat > $t <<EOT
#include <ucontext.h>

int main()
{
  ucontext_t context;
  context.uc_mcontext.uc_regs = 0;
}
EOT
test_cxx "whether ucontext uses uc_regs" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_CONTEXT_FPU_POINTER_UCREGS, $pass, [whether ucontext uses uc_regs union])
fi

cat > $t <<EOT
#include <ucontext.h>
vrregset_t *v_regs;
ucontext_t  uc;

void foo()
{
  vrregset_t *ptr = uc.uc_mcontext.v_regs;
}
EOT
test_cxx "whether ucontext has pointer (v_regs) of vector type" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_CONTEXT_V_REGS, $pass, [whether ucontext has pointer (v_regs) of vector type])

###################### C++ Compiler Features #####################

#### check C inline ####
cat > $tc <<EOT
inline static int foo()
{
  return 1;
}
EOT
test_cc "whether inline works in C" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_C_INLINE, $strictpass, [whether C inline works in C])

#### check explicit ####
cat > $t <<EOT
#include <stdlib.h>
class er {
 protected:
   explicit er(unsigned int inType) {};
};
EOT
test_cxx "whether C++ class explicit keyword works" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_EXPLICIT, $pass, [whether C++ class explicit keyword works])

#### check if signed char is same as char ####
cat > $t <<EOT
#include <stdlib.h>
class er {
 protected:
   void operator()(char &v,const char *desc=NULL) {};
   void operator()(signed char &v,const char *desc=NULL) {};
};
EOT
test_cxx "whether C++ signed char and char differ" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_SIGNEDCHAR_DIFF_CHAR, $pass, [whether C++ signed char and char differ])

#### check if C++ casts work ####
cat > $t <<EOT
int foo(float *t) {return *reinterpret_cast<int *>(t);}
EOT
test_cxx "whether C++ *_casts<> work" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_CPP_CAST_LEGAL, $pass, [C++ *_casts<> work])
AC_DEFINE_UNQUOTED(CMK_CPP_CAST_ILLEGAL, $fail, [C++ *_casts<> does not work])


### check if varsize array on stack ####
cat > $t <<EOT
#include <stdio.h>
void foo()
{
  int size=10;
  char arr[size];
}

EOT
test_cxx "whether C++ allows declaration of varsize array" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_DECLARE_VARSIZE_ARRAY, $pass, [whether C++ allows declaration of variable sized array])

##### check if the stl headers use .h #####
cat > $t <<EOT
#include <iostream>
void foo(void) { std::cout<<"Hello, world"<<std::endl; }
EOT
test_cxx "whether including STL <foo> works" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_STL_USE_DOT_H, $fail, [including STL <foo> does not works])
AC_DEFINE_UNQUOTED(CMK_STL_DONT_USE_DOT_H, $pass, [including STL <foo> works])

#### check if std::vector works ######
cat > $t <<EOT
#include <vector>

int foo(void) {
  std::vector<int> v;      
  v.push_back(2); v.push_back(3);
  std::vector<int>::iterator it=v.begin();
  it++;
  return *it;
}
EOT
test_cxx "whether the std:: names for STL work" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_USE_STL, $pass, [whether the std:: names for STL work])

#### check if namespaces can be defined #####
cat > $t <<EOT
namespace foo {
	int x;
}
EOT
test_cxx "whether namespaces work" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_NAMESPACES_BROKEN, $fail, [whether namespaces work])


#### check if typeinfo exists and works #####
cat > $t <<EOT
#include <typeinfo>
const char *foo(void) {
	int x;
	return typeid(x).name();
}
EOT
test_cxx "whether typeinfo/typeid works" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_TYPEINFO, $pass, [whether typeinfo/typeid works])

#### check if iterator_traits is defined #####
cat > $t <<EOT
#include <iterator>

template <typename T> // T models Input Iterator
typename std::iterator_traits<T>::value_type accumulate(T first, T last)
{
      typename std::iterator_traits<T>::value_type result = 0;
      while(first != last)
            result += *first++;
      return result;
}
EOT
test_cxx "whether std::iterator_traits is defined" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_ITERATOR_TRAITS, $pass, [whether iterator_traits works])

#### check if std::distance is defined #####
cat > $t <<EOT
#include <vector>
#include <iterator>

int foo()
{
  std::vector<int> tree;
  return std::distance(tree.begin(), tree.end());
}
EOT
test_cxx "whether std::distance is defined" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_STD_DISTANCE, $pass, [whether std::distance works])

#### check if std::inserter is defined #####
cat > $t <<EOT
#include <list>
#include <iterator>

void foo()
{
  using namespace std;
  list<int> L;
  inserter ( L, L.end ( ) ) = 500;
}
EOT
test_cxx "whether std::inserter is defined" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_STD_INSERTER, $pass, [whether std::inserter works])


#### test if we can have multiple delete like this ####
cat > $t <<EOT
class foo {
public:
  void operator delete(void*p){};
  void operator delete(void*p,int*){};
};
EOT
test_cxx "whether operator delete can be overloaded in same class" "ok" "no" ""
AC_DEFINE_UNQUOTED(CMK_MULTIPLE_DELETE, $strictpass, [whether operator delete can be overloaded in same class])


#### test if we can use gcc x86 assembly like this ####
cat > $t <<EOT
double foo(void)
{
  unsigned long long int v;
  int *lo=0+(int *)&v;
  int *hi=1+(int *)&v;
  __asm__ __volatile__(
      "rdtsc; movl %%edx,%0; movl %%eax,%1"
      : /* output  */ "=m" (*hi), "=m" (*lo)
      : /* input */
      : /* trashes */ "%edx", "%eax"
  );
  return v;
}
EOT
test_cxx "whether GCC x86 assembly works" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_GCC_X86_ASM, $strictpass, [Allows gcc x86 assembly.])

#### test if we can use gcc x86 assembly like this ####
if test $strictpass = 1
then
cat > $t <<EOT
int foo(void)
{
  int x;
  asm("lock incl %0" :: "m" (x));
  asm("lock decl %0" :: "m" (x));
  return x;
}
EOT
test_cxx "whether GCC x86 assembly for atomic increment works" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_GCC_X86_ASM_ATOMICINCREMENT, $strictpass, [Allows gcc x86 assembly for atomic increment.])
fi

#### test if we can use gcc IA64 assembly like this ####
cat > $t <<EOT
double foo(void)
{
        unsigned long long int x;
	__asm__ __volatile__("mov %0=ar.itc" : "=r"(x) :: "memory");
        return x;
}
EOT
test_cxx "whether GCC IA64 assembly works" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_GCC_IA64_ASM, $strictpass, [Allows gcc IA64 assembly.])


#### test if we can use PPC assembly like this ####
cat > $t <<EOT
double foo(void)
{
        unsigned long long int x;
	asm volatile("eieio" ::: "memory");
        return x;
}
EOT
test_cxx "whether PPC assembly works" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_PPC_ASM, $strictpass, [Allows PPC assembly.])



#### test if we can use __thread ####
cat > $t <<EOT
__thread unsigned long long int x;
static __thread  int y;
void foo(void)
{
	x = 1;
	y = 1;
}
EOT
test_cxx "whether __thread (Thread Local Storage) is supported" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_TLS_THREAD, $strictpass, [Allows __thread.])

### test if switching TLS register ###
if test $in64bit = 1
then
cat > $t <<EOT
#include <elf.h>
#include <stdlib.h>
#include <malloc.h>

void switchTLS() {
  Elf64_Addr m1, m2;
  asm volatile ("movq %%fs:0x0, %0\n\t"
                "movq %1, %%fs:0x0\n\t"
                : "=r"(m1)
                : "r"(m2));
}
EOT
test_cxx "whether switching TLS register (64-bit) is supported" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_TLS_SWITCHING64, $strictpass, [Allows switching TLS 64-bit.])
else
cat > $t <<EOT
#include <elf.h>
#include <stdlib.h>
#include <malloc.h>

void switchTLS() {
  Elf32_Addr m1, m2;
  asm volatile ("movl %%gs:0x0, %0\n\t"
                "movl %1, %%gs:0x0\n\t"
                : "=r"(m1)
                : "r"(m2));
}
EOT
test_cxx "whether switching TLS register (32-bit) is supported" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_TLS_SWITCHING32, $strictpass, [Allows switching TLS in 32-bit.])
fi

#### test if we can build MPI ####
if test "$CMK_BUILD_MPI" = 1
then

cat > $t <<EOT
#include "mpi.h"
int main(int argc, char **argv)
{
  MPI_Init(&argc, &argv);
}
EOT
mv -f ../include/mpi.h ../include/mpi.h.bak 2>/dev/null
test_cxx "whether build on MPI" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_BUILD_ON_MPI, $strictpass, [build MPI.])
BUILD_MPI=$strictpass

if test $BUILD_MPI -eq 0
then
  echo "Error: Can not compile a MPI program"
  test_finish 1
fi

if test $BUILD_MPI -eq 1
then
  test_link "whether need to specify MPI library" "no" "yes" ""
  if test $pass -ne 1
  then
    if test -z "$CMK_MPI_LIB"
    then
      test_link "whether -lmpich" "ok" "no" "-lmpich"
      if test $pass -eq 1
      then
        add_flag CMK_SYSLIBS='"$CMK_SYSLIBS -lmpich"' "mpi lib"
      else
        test_link "whether -lmpi" "ok" "no" "-lmpi"
        if test $pass -eq 1
        then
                add_flag CMK_SYSLIBS='"$CMK_SYSLIBS -lmpi"' "mpi lib"
        else
                echo "Error: can not find mpi library"
                test_finish 1
        fi
      fi
    else
      add_flag CMK_SYSLIBS='"$CMK_SYSLIBS $CMK_MPI_LIB"' "mpi lib"
    fi
  fi
fi

if test "$BUILD_MPI" = "1"
then
cat > $t <<EOT
#include "mpi.h"
int main(int argc, char **argv)
{
  int thread_level, provided;
  thread_level = MPI_THREAD_FUNNELED;
  MPI_Init_thread(&argc, &argv, thread_level, &provided);
}
EOT
test_cxx "whether MPI_Init_thread is supported" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_MPI_INIT_THREAD, $strictpass, [Allows MPI_Init_thread.])
fi
mv -f ../include/mpi.h.bak ../include/mpi.h 2>/dev/null

fi

################### Syscalls and Libraries ###################

#### test for getrusage with RUSAGE_THREAD ###
cat > $tc <<EOT
#include <sys/time.h>
#define __USE_GNU   1
#include <sys/resource.h>
int main() {
  struct rusage usage;
  getrusage(RUSAGE_THREAD, &usage);
  return 0;
}
EOT
test_linkc "whether getrusage accepts RUSAGE_THREAD" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_RUSAGE_THREAD, $pass, [whether getrusage accepts RUSAGE_THREAD])

#### test for log2 ###
cat > $t <<EOT
#include <math.h>
int main() {
  int i = log2(10);
  return 0;
}
EOT
test_link "whether has log2" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_LOG2, $pass, [whether has log2])

#### test for sqrtf ###
cat > $t <<EOT
#include <math.h>
int main() {
  float i = sqrtf((float)10.0);
  return 0;
}
EOT
test_link "whether has sqrtf" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_SQRTF, $pass, [whether has sqrtf])

#### test for fabsf ###
cat > $t <<EOT
#include <math.h>
int main() {
  float i = fabsf((float)10.0);
  return 0;
}
EOT
test_link "whether has fabsf" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_FABSF, $pass, [whether has fabsf])

#### test for mkstemp ###
cat > $t <<EOT
#include <stdlib.h>
#include <string.h>
int main() {
  char fname[[128]];
  strcpy(fname, "/tmp/fdXXX.XXX");
  mkstemp(fname);
  return 0;
}
EOT
test_link "whether has mkstemp" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_USE_MKSTEMP, $pass, [whether has mkstemp])

#### test for system ###
cat > $t <<EOT
#include <stdlib.h>
int main() {
  system("/bin/ls");
  return 0;
}
EOT
test_link "whether has system" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_SYSTEM, $pass, [whether has system])

#### test for sbrk ###
cat > $t <<EOT
#include <unistd.h>
int main() {
  void *ptr  = sbrk(0); 
}
EOT
test_link "whether has sbrk" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_SBRK, $pass, [whether has sbrk])

#### test for mstats ###
cat > $t <<EOT
#include <malloc.h>
int main() {
  struct mstats ms = mstats();
}
EOT
test_link "whether has mstats" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_MSTATS, $pass, [whether has mstats])

#### test for mallinfo ###
cat > $t <<EOT
#include <malloc.h>
int main() {
  struct mallinfo mi = mallinfo();
}
EOT
test_link "whether has mallinfo" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_MALLINFO, $pass, [whether has mallinfo])

#### test for popen ###
cat > $t <<EOT
#include <stdio.h>
int main() {
  FILE *p = popen("/bin/ps", "r");
  pclose(p);
}
EOT
test_link "whether has popen" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_POPEN, $pass, [whether has popen])

#### test for poll ###
cat > $t <<EOT
#include <poll.h>
void foo(void) { 
  struct pollfd pos[[3]];
  poll(pos, 1, 1);
}
EOT
test_cxx "whether has poll" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_USE_POLL, $pass, [whether the poll syscall exists])

#### check if getpagesize exists ####
cat > $tc <<EOT
#include <unistd.h>

int main(int argc, char **argv) {
    int s = getpagesize();
}
EOT
test_linkc "whether has getpagesize" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_GETPAGESIZE, $pass, [whether getpagesize exists])

#### check if getpid exists ####
cat > $tc <<EOT
#include <sys/types.h>
#include <unistd.h>

int main(int argc, char **argv) {
    pid_t pid = getpid();
}
EOT
test_linkc "whether has getpid" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_GETPID, $pass, [whether getpid exists])

#### check if kill exists ####
cat > $tc <<EOT
#include <sys/types.h>
#include <unistd.h>
#include <signal.h>

int main(int argc, char**argv) 
{
    pid_t pid = getpid();
    kill(pid, 9);
}
EOT
test_linkc "whether has kill" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_KILL, $pass, [whether kill exists])

#### test for setpriority ###
cat > $t <<EOT
#include <sys/time.h>
#include <sys/resource.h>
void foo(void) { 
  setpriority(PRIO_PROCESS, 0, 0);
}
EOT
test_cxx "whether has setpriority" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_SETPRIORITY, $pass, [whether the setpriority exists])

#### test for system ###
cat > $t <<EOT
#include "ckdll_system.C"
EOT
test_cxx "whether to use signal-safe system() " "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_SIGSAFE_SYSTEM, $pass, [whether to use signal-safe system()])

### test sched_setaffinity ####
cat > $tc <<EOT
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

#define _GNU_SOURCE
#include <sched.h>
long sched_setaffinity(pid_t pid, unsigned int len, unsigned long *user_mask_ptr);
long sched_getaffinity(pid_t pid, unsigned int len, unsigned long *user_mask_ptr);

int main()
{
  unsigned long mask = 0xffffffff;
  unsigned int len = sizeof(mask);

  if (sched_setaffinity(0, len, &mask) < 0) {
    return -1;
  }
  return 0;
}
EOT
test_linkc "whether sched_setaffinity call exists" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_SETAFFINITY, $pass, [whether the sched_setaffinity() exists])

### test pthread_setaffinity_np ####
cat > $tc <<EOT
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

int main()
{
  unsigned long mask = 0xffffffff;
  unsigned int len = sizeof(mask);

  if (pthread_setaffinity_np(pthread_self(), len, &mask) < 0) {
    return -1;
  }
  return 0;
}
EOT
test_linkc "whether pthread_setaffinity_np call exists" "yes" "no" "-lpthread"
AC_DEFINE_UNQUOTED(CMK_HAS_PTHREAD_SETAFFINITY, $pass, [whether the pthread_setaffinity_np() exists])


### check libnuma on Linux ####
if test "$WITH_NUMA" = "yes"
then
cat > $tc <<EOT
#include <stdlib.h>
#include <stdio.h>
#include <linux/mempolicy.h>
#include <numaif.h>
#include <numa.h>

int main()
{
  if (get_mempolicy(NULL, NULL, 0, 0, 0) == 0) return 0;
  return -1;
}
EOT
test_linkc "whether libnuma exists" "yes" "no" "-lnuma"
AC_DEFINE_UNQUOTED(CMK_HAS_NUMACTRL, $pass, [whether NUMA control related functions exist])
if test $pass -eq 1
then
        add_flag 'CMK_SYSLIBS="$CMK_SYSLIBS -lnuma"' "libnuma"
fi
fi

#### check bindprocessors on AIX ####
cat > $tc <<EOT
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

#include <sys/processor.h>

int main()
{
  int retValue = 0;
  int pid;
  pid = getpid();
  if (bindprocessor(BINDPROCESS, pid, 0) == -1) return -1;
  return 0;
}
EOT
test_linkc "whether bindprocessor call exists" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_BINDPROCESSOR, $pass, [whether the bindprocessor()
exists])


#### check if dlopen works ####
skip_dl=0
# for bproc, ignore -ldl
test -n "$CMK_BPROC" && skip_dl=1
test -n "$CMK_NO_DL" && skip_dl=1
dl_opt='-ldl'
#workaround for pgcc 4.0, -ldl crash linking, so use -Wl,-ldl to skip the prelinker.
case "$CMK_CXX" in
pgCC*) dl_opt='-Wl,-ldl' ;;
esac

if test $skip_dl -eq 0 
then

cat > $t <<EOT
#include "ckdll_dlopen.C"
int main() {
	CkDll dll("foo.so");
	return 0;
}
EOT
test_link "whether dlopen links without $dl_opt" "yes" "no" ""
noldl=$pass
test_link "whether dlopen links with $dl_opt" "yes" "no" "$dl_opt"
if test $pass -eq 1
then 
#dlopen requires -ldl: add it to our link line
	add_flag CMK_LIBS='"$CMK_LIBS '$dl_opt'"' "dlopen"
fi

if test $pass -eq 1 -o $noldl -eq 1
then
# One version or another of dlopen worked: compile it in
	AC_DEFINE_UNQUOTED(CMK_DLL_USE_DLOPEN, 1, [dlopen])
fi

### test gethostname ####
cat > $tc <<EOT
#ifdef WIN32
#include <Winsock2.h>
#else
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#endif

int main()
{
  char hostname[[1000]];
  gethostname(hostname, 999);
  return 0;
}
EOT
test_linkc "whether gethostname call exists" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_GETHOSTNAME, $pass, [whether gethostname() exists])

#### check if getProcAddress works ####
cat > $t <<EOT
#include "ckdll_win32.C"
EOT
test_cxx "whether getProcAddress works" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_DLL_USE_WIN32, $pass, [whether getProcAddress works])

fi    # end of skip_dl

#### check if socklen_t exists ####
cat > $t <<EOT
#include <sys/types.h>
#include <sys/socket.h>

void foo(void) {
	int i;
	socklen_t s=sizeof(i);
}
EOT
test_cxx "whether has socklen_t" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_SOCKLEN, $pass, [whether has socklen_t])

### test getifaddrs ####
cat > $tc <<EOT
#include <netinet/in.h> /* for sockaddr_in */
#include <ifaddrs.h> /* for getifaddrs */
#include <net/if.h> /* for IFF_RUNNING */

int main()
{
  struct ifaddrs *interfaces=0;
  if( getifaddrs(&interfaces) == 0 ) {
        struct ifaddrs *interface;
        for( interface=interfaces; interface; interface=interface->ifa_next ) {
            if( (interface->ifa_flags & IFF_UP) && ! (interface->ifa_flags & IFF_LOOPBACK) ) {
                const struct sockaddr_in *addr = (const struct sockaddr_in*)interface->ifa_addr;
                if( addr && addr->sin_family==AF_INET ) {
                    break;
                }
            }
        }
        freeifaddrs(interfaces);
  }
}
EOT
test_linkc "whether getifaddrs call exists" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_GETIFADDRS, $pass, [whether getifaddrs() exists])

#### check if mmap exists ####
cat > $t <<EOT
#include <sys/types.h>
#include <sys/mman.h>

void *foo(void *a,int l,int fd) {
	return mmap((caddr_t)a,l,PROT_READ+PROT_WRITE,
                 MAP_FIXED+MAP_PRIVATE,fd,0);
}
EOT
test_cxx "whether the mmap() syscall exists" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_MMAP, $pass, [whether the mmap() syscall exists])

#### check if mmap accepts MAP_ANON ####
cat > $t <<EOT
#include <sys/types.h>
#include <sys/mman.h>

void *foo(void *a,int l) {
	return mmap((caddr_t)a,l,PROT_READ+PROT_WRITE,
                MAP_FIXED+MAP_PRIVATE+MAP_ANON,-1,0);
}
EOT
test_cxx "whether mmap() accepts MAP_ANON" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_MMAP_ANON, $pass, [whether mmap() accepts MAP_ANON])

#### check if mmap accepts MAP_NORESERVE ####
cat > $t <<EOT
#include <sys/types.h>
#include <sys/mman.h>

void *foo(void *a,int l) {
	return mmap((caddr_t)a,l,PROT_READ+PROT_WRITE,
                MAP_FIXED+MAP_PRIVATE+MAP_NORESERVE,-1,0);
}
EOT
test_cxx "whether mmap() accepts MAP_NORESERVE" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_MMAP_NORESERVE, $pass, [whether mmap() accepts MAP_NORESERVE])

#### check if get_myaddress exists ####
cat > $t <<EOT
#include <rpc/rpc.h>

void foo(void *a) {
    get_myaddress((struct sockaddr_in*)a);
}
EOT
test_cxx "whether get_myaddress() exists" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_GET_MYADDRESS, $pass, [whether get_myaddress() exists])

#### check if glibc backtrace exists ####
cat > $t <<EOT
#include "cmibacktrace.c"

int main() {
	int nLevels=1;
	void *stack;
	CmiBacktraceRecord(&stack,0,&nLevels);
	return 0;
}
EOT
TRACE_LINK_FLAG="-rdynamic"
test_link "whether glibc backtrace works" "yes" "no" "-DCMK_USE_BACKTRACE=1 $TRACE_LINK_FLAG"
AC_DEFINE_UNQUOTED(CMK_USE_BACKTRACE, $pass, [whether glibc backtrace works])

if test $strictpass -eq 1
then 
	add_flag 'CMK_LD="$CMK_LD '$TRACE_LINK_FLAG'"' "backtrace"
	add_flag 'CMK_LDXX="$CMK_LDXX '$TRACE_LINK_FLAG'"' "backtrace"
fi

#### test sleep ####
cat > $t <<EOT
#include <unistd.h>
int main() {
  sleep(1);
  return 0;
}
EOT
test_cxx "whether has sleep " "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_SLEEP, $pass, [whether has sleep])

#### test usleep ####
cat > $t <<EOT
#include <unistd.h>
int main() {
  usleep(100);
  return 0;
}
EOT
test_cxx "whether has usleep " "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_USLEEP, $pass, [whether has usleep])

#### test personality() and ADDR_NO_RANDOMIZE ####
# Only works on modern Linux systems
cat > $t <<EOT
#include <sys/personality.h>
int main() {
    int orig_persona = personality(0xffffffff);
    personality(orig_persona | ADDR_NO_RANDOMIZE);
    return 0;
}
EOT
test_cxx "whether personality() and ADDR_NO_RANDOMIZE exist" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_ADDR_NO_RANDOMIZE, $pass, [whether personality() and ADDR_NO_RANDOMIZE exist])


#### test if has zlib ####
# bproc doesnot like -lz in any case
if test -z "$CMK_BPROC"
then

cat > $t <<EOT
#include <zlib.h>
int main() { 
  gzFile f = gzopen("/tmp/x","r");
  gzprintf(f, "test...\n");
  gzclose(f);
  return 0;
}
EOT
test_link "whether has zlib" "yes" "no" "-lz"
AC_DEFINE_UNQUOTED(CMK_PROJECTIONS_USE_ZLIB, $pass, [whether has zlib])
if test $pass -eq 1
then 
	add_flag 'CMK_LIBZ="-lz"' "zlib"
fi

fi

#### test if has elf.h ####
cat > $t <<EOT
#include <elf.h>
typedef Elf32_Addr ELF_TYPE_Addr;
int main() { 
}
EOT
test_cxx "whether has elf.h " "yes" "no" ""
AC_DEFINE_UNQUOTED([CMK_HAS_ELF_H], $pass, [whether has elf.h])

#### test if has Multiprocessing.h for apple ####
cat > $t <<EOT
#include <Carbon/Carbon.h>
#include <Multiprocessing.h>
int main() {
  int a = MPProcessorsScheduled();
}
EOT
test_cxx "whether has Multiprocessing.h for Apple " "yes" "no" ""
AC_DEFINE_UNQUOTED([CMK_HAS_MULTIPROCESSING_H], $pass, [whether has Multiprocessing.h])

#### test if "ntohl" is available ####
cat > $t <<EOT
#if defined(_WIN32) && ! defined(__CYGWIN__) || defined(__MINGW_H)
#include <winsock.h>
#else
#include <netinet/in.h>
#include <arpa/inet.h>
#endif

int main() {
  int i = 100;
  i = ntohl(i);
  return 0;
}
EOT
test_link "whether ntohl is available" "yes" "no" ""
AC_DEFINE_UNQUOTED(CMK_HAS_NTOHL, $pass, [whether ntohl is available])

### test for libjpeg ####
cat > $t <<EOT
#include <stdio.h>
#include <stdlib.h>
#include "jpeglib.h"

int main()
{
  struct jpeg_compress_struct cinfo;
  jpeg_create_compress(&cinfo);
  return 0;
}
EOT
test_link "whether has libjpeg" "yes" "no" "-ljpeg"
AC_DEFINE_UNQUOTED(CMK_USE_LIBJPEG, $pass, [whether has libjpeg])
if test $pass -eq 1
then
        add_flag 'CMK_LIBJPEG="-ljpeg"' "libjpeg"
fi

#### check if PAPI exists ####
if test -n "$CMK_USE_PAPI"
then
cat > $t <<EOT
#include <stdio.h>
#include <papi.h>
                                                                                
int main() {
    int Events[[1]] = { PAPI_TOT_CYC };
    if (PAPI_start_counters(Events, 1) != PAPI_OK) return 1;
    return 0;
}
EOT
test_link "whether PAPI exists" "yes" "no" "-lpapi"
AC_DEFINE_UNQUOTED(CMK_HAS_COUNTER_PAPI, $pass, [whether PAPI exists])
if test $pass -eq 1
then 
	add_flag 'CMK_LIBS="$CMK_LIBS -lpapi"' "papi"
fi
fi

#### test if Python headers are installed ####
PYTHON_VERSION=`python -V 2>&1 | awk {'print $2'} | awk -F. {'print $1"."$2'}`
cat > $t <<EOT
#include "python${PYTHON_VERSION}/Python.h"
#include "python${PYTHON_VERSION}/compile.h"
#include "python${PYTHON_VERSION}/eval.h"
#include "python${PYTHON_VERSION}/node.h"

int main() {
    Py_Initialize();
    PyEval_InitThreads();
    struct _node* programNode = PyParser_SimpleParseString("return 1\n",Py_file_input);
    PyCodeObject *program = PyNode_Compile(programNode, "");
}
EOT
test_link "whether Python is installed" "yes" "no" "-lpython$PYTHON_VERSION -lpthread -lutil -ldl"
AC_DEFINE_UNQUOTED(CMK_HAS_PYTHON, $pass, [whether Python is installed])
AC_DEFINE_UNQUOTED(CMK_PYTHON_VERSION, ${PYTHON_VERSION}, [Python version])
if test $pass -eq 1
then
	add_flag "CMK_BUILD_PYTHON=$PYTHON_VERSION" "python"
fi

#### test if it can build shared library ####
cat > $t <<EOT
#include "stdlib.h"
extern int foo();
int foo1() { 
  void * t= malloc(2);
  foo();
  return 0;
}
EOT
test_linkso "whether can build shared library" "yes" "no" ""
if test $pass -eq 0
then 
	add_flag 'CMK_NO_BUILD_SHARED="true"' "build-shared"
else
	BUILD_SHARED=1
        if test "$BUILD_MPI" = "1"
	then
cat > $t <<EOT
#include "stdlib.h"
#include "mpi.h"
extern int foo();
int foo(int argc, char ** argv) {
  void * t= malloc(2);
  foo();
  MPI_Init(&argc, &argv);
  return 0;
}
EOT
		test_linkso "whether can build shared library with MPI" "yes" "no" ""
		BUILD_SHARED=$pass
	fi
	if test $BUILD_SHARED -eq 1
	then
		add_flag 'CMK_NO_BUILD_SHARED="false"' "build-shared"
	else
		add_flag 'CMK_NO_BUILD_SHARED="true"' "build-shared"
	fi
fi

#### test the version number of bproc ####
if test -n "$CMK_BPROC"
then
cat > $t <<EOT
#include <stdio.h>
#include <sys/bproc.h>
int main()
{
  struct bproc_version_t vers;
  bproc_version(&vers);
  printf("%s\n", vers.version_string);
}
EOT
test_link "whether bproc compiles" "yes" "no" "-lbproc"
if test $pass -eq 1
then 
AC_MSG_CHECKING("bproc version")
bproc_ver=`./testlink`
if test x$bproc_ver = x
then
test_result 0 "bproc version" "ERROR" ""
test_finish 1
else
test_result 0 "bproc version" "$bproc_ver" ""
fi
bproc_ver=`echo $bproc_ver | cut -d'.' -f1`
AC_DEFINE_UNQUOTED(CMK_BPROC_VERSION, $bproc_ver, [bproc version])
fi
fi

#### test the if command sync exists ####
AC_CHECK_PROG(SYNC, sync, sync )
if test -n "$SYNC"
then
AC_DEFINE_UNQUOTED(CMK_HAS_SYNC, 1, [sync program])
fi

################## Fortran #########################

#echo "set F77 compiler as: $CMK_CF77"
AC_MSG_CHECKING("F77 compiler as")
AC_MSG_RESULT("$CMK_CF77")

AC_MSG_CHECKING("whether Fortran 77 compiler works")
### test fortran 77 compiler ###
cat > conftest.f <<EOF
      SUBROUTINE FOO_foo
      END
EOF
$CMK_CF77 -c conftest.f > /dev/null 2> /dev/null
if test ! -r conftest.o
then
  AC_MSG_RESULT("no")
else
  AC_MSG_RESULT("yes")
fi

### test fortran 90 compiler ###
#echo "set F90 compiler as: $CMK_CF90"
AC_MSG_CHECKING("F90 compiler as")
AC_MSG_RESULT("$CMK_CF90")

AC_MSG_CHECKING("whether Fortran 90 compiler works")
cat > conftest2.f90 <<EOF
      SUBROUTINE FOO_foo
      END
EOF
$CMK_CF90 -c conftest2.f90 > /dev/null 2> /dev/null
if test ! -r conftest2.o
then
  AC_MSG_RESULT("no")
else
  AC_MSG_RESULT("yes")
  mv -f conftest2.o conftest.o
  USE_FORTRAN90=1
fi

### check fortran name mangling
AC_MSG_CHECKING(subroutine name used by Fortran 90 compiler)

if test -r conftest.o
then
  AC_CACHE_VAL(_cv_fortran_postfix,

  NAME=`$CMK_NM conftest.o | grep "foo_foo__"`
  if test "$NAME" != ""
  then
    _cv_fortran_postfix=TWOSCORE
    AC_DEFINE_UNQUOTED(CMK_FORTRAN_USES_TWOSCORE, 1, [TWOSCORE])
  else
    NAME=`$CMK_NM conftest.o | grep "foo_foo_"`
    if test "$NAME" != ""
    then
      _cv_fortran_postfix=ONESCORE
      AC_DEFINE_UNQUOTED(CMK_FORTRAN_USES_ONESCORE, 1, [ONESCORE])
    else
      NAME=`$CMK_NM conftest.o | grep "foo_foo"`
      if test "$NAME" != ""
      then
        _cv_fortran_postfix=NOSCORE
        AC_DEFINE_UNQUOTED(CMK_FORTRAN_USES_NOSCORE, 1, [NOSCORE])
      else
        NAME=`$CMK_NM conftest.o | grep "FOO_FOO"`
        if test "$NAME" != ""
        then
          _cv_fortran_postfix=ALLCAPS
          AC_DEFINE_UNQUOTED(CMK_FORTRAN_USES_ALLCAPS, 1, [ALLCAPS])
        else
          echo "#################################################"
          echo "FORTRAN compiler generated name not supported yet"
          echo "#################################################"
        fi
      fi
    fi
  fi
  rm -f conftest.f conftest.o
  )
  AC_MSG_RESULT($_cv_fortran_postfix)
else
  AC_MSG_RESULT("Fortran compiler not working")
fi

### check module name ###

if test "$USE_FORTRAN90" = 1
then
  cat > conftest.f90 <<EOF
      MODULE testmod
        interface 
          function fpup_issizing(p)
          INTEGER :: p
          logical fpup_issizing
          end function
        end interface
      END MODULE
EOF
  AC_MSG_CHECKING(Fortran 90 mod name is capital)
  $CMK_CF90 -c conftest.f90 > /dev/null 2> /dev/null
  name=`ls TESTMOD.* 2>/dev/null`
  if test -n "$name"
  then
        AC_MSG_RESULT("yes")
	add_flag 'CMK_MOD_NAME_ALLCAPS=1' "mod name capital"
  else
        AC_MSG_RESULT("no")
	name=`ls testmod.* 2>/dev/null`
  fi
  if test -n "$name"
  then
  	AC_MSG_CHECKING(Fortran 90 mod name extension)
    	ext=`echo $name | sed -e 's/^[[^.]]*\.//'`
	add_flag 'CMK_MOD_EXT="'$ext'"' "mod name extension"
        AC_MSG_RESULT("$ext")
        /bin/rm -f $name
  fi
  /bin/rm -f conftest.f90
fi

AC_OUTPUT(
libs/ck-libs/ampi/ampiCC libs/ck-libs/ampi/ampirun,

chmod +x libs/ck-libs/ampi/ampiCC libs/ck-libs/ampi/ampirun
)
