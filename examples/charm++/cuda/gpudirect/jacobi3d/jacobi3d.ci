mainmodule jacobi3d {
  include "jacobi3d.h";

  readonly CProxy_Main main_proxy;
  readonly CProxy_Block block_proxy;
  readonly int num_chares;
  readonly int grid_width;
  readonly int grid_height;
  readonly int grid_depth;
  readonly int block_width;
  readonly int block_height;
  readonly int block_depth;
  readonly int x_surf_count;
  readonly int y_surf_count;
  readonly int z_surf_count;
  readonly size_t x_surf_size;
  readonly size_t y_surf_size;
  readonly size_t z_surf_size;
  readonly int n_chares_x;
  readonly int n_chares_y;
  readonly int n_chares_z;
  readonly int n_iters;
  readonly int warmup_iters;
  readonly bool use_channel;
  readonly bool host_staging;
  readonly bool manual_overlap;
  readonly bool fuse_pack;
  readonly bool fuse_unpack;
  readonly bool fuse_update_pack;
  readonly bool fuse_update_all;
  readonly bool use_cuda_graph;
  readonly bool print_elements;

  message CallbackMsg;

  mainchare Main {
    entry Main(CkArgMsg* m);
    entry [reductiontarget] void initDone();
    entry void startIter();
    entry [reductiontarget] void warmupDone();
    entry [reductiontarget] void allDone();
  };

  array [3D] Block {
    entry Block(void);
    entry void init();
    entry void recvChannelID(int dir, int id);
    entry void packGhostsDone();
    entry void recvGhostReg(int ref, int dir, int count, DataType gh[count]);
    entry void channelCallback(CallbackMsg* msg);
    entry void updateDone();
    entry void print();

    entry void initDone() {
      if (use_channel) {
        serial {
          sendChannelIDs();
        }

        // Wait for channel IDs from "lower" neighbors
        for (nbr_count = 0; nbr_count < n_low_nbr; nbr_count++) {
          when recvChannelID(int dir, int id) serial {
            channel_ids[dir] = id;
          }
        }

        serial {
          createChannels();

          if (use_cuda_graph) {
            createCudaGraphs();
          }
        }
      }

      serial {
        contribute(CkCallback(CkReductionTarget(Main, initDone), main_proxy));
      }
    }

    entry void run() {
      // Pack and send ghost data to neighbors
      serial {
        packGhosts();
      }

      when packGhostsDone() serial {
        sendGhosts();
      }

      // Receive ghost data from neighbors
      if (use_channel) {
        serial {
          recvGhosts();
        }

        for (nbr_count = 0; nbr_count < 2 * n_nbr; nbr_count++) {
          when channelCallback[my_iter](CallbackMsg* msg) serial {
            processTimer();
            if (msg->recv && !fuse_update_all && !fuse_unpack && !use_cuda_graph) {
              processGhostChannel(msg->dir);
            }
            delete msg;
          }
        }

        if (use_cuda_graph) {
          serial {
            launchCudaGraph();
          }
        } else {
          if (fuse_unpack) {
            serial {
              processGhostsFused();
            }
          }
        }
      } else {
        for (nbr_count = 0; nbr_count < n_nbr; nbr_count++) {
          when recvGhostReg[my_iter](int ref, int dir, int count, DataType buf[count]) {
            serial {
              processGhostReg(dir, count, buf);
            }
          }
        }
      }

      // Perform Jacobian update
      serial {
        update();
      }
    }
  };
};
