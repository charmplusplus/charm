mainmodule iotest {
  include "ckio.h";

  mainchare Main {
    entry Main(CkArgMsg *m);
    entry void ready(Ck::IO::FileReadyMsg *m);

    entry void run(int iter) {
      serial {
        Ck::IO::Options opts;
        Ck::IO::FileOps Operation = Ck::IO::FileOps::ReadPe; // Newly Added With enum
        opts.peStripe = 200;
        opts.writeStripe = 1;
        opts.peRW = Operation;
        CkCallback opened(CkIndex_Main::ready(NULL), thisProxy);
        opened.setRefnum(iter + 0);
        Ck::IO::open(fileName, opened, opts);
      }
      when ready[iter + 0](Ck::IO::FileReadyMsg *m) serial {
        
        f.at(iter/4) = m->file;

        CkCallback sessionStart(CkIndex_Main::start_io(0), thisProxy);
        sessionStart.setRefnum(iter + 1);
        
        CkCallback sessionEnd(CkIndex_Main::closed(0), thisProxy);
        
        sessionEnd.setRefnum(iter + 3);
        Ck::IO::startSession(f.at(iter/4), fileSize, 0, sessionStart,
                             sessionEnd);
        delete m;
        CkPrintf("Main saw file ready\n");
      }
      when start_io[iter + 1](Ck::IO::SessionReadyMsg *m) serial{  
        testers = CProxy_test::ckNew(m->session, n, fixedBytesToRead, remainingBytes, n);
        CkPrintf("Main saw session ready\n");
        delete m;
      }
      when closed[iter + 3](CkReductionMsg *m) serial {
        CkPrintf("Main saw close done\n");
        delete m;
        thisProxy.iterDone(m);
      }
    };

    entry void start_io(Ck::IO::SessionReadyMsg *m);
    entry void closed(CkReductionMsg *m);
    entry void iterDone(CkReductionMsg *m);
    entry void testReadFiles(int offset, int size, char data[size]);
  };

  array [1D] test {
    //entry test(Ck::IO::Session token,int n);
    entry test(Ck::IO::Session token,int n, int fixedBytesToRead, int remainingBytes);
    entry void readCompleted(Ck::IO::SessionReadyMsg *m);
    entry void done(Ck::IO::Session token, int n);
  }
}
